---
layout: post
title:  "😂 C언어 기억을 살리자!"
date:   2019-03-03 18:34:10 +0700
categories: [c]
---

> 포스팅 제목 그대로 기억에서 잊혀져가는 c언어를 되살리기 위한 포스팅이다!
> 
> 🙋‍ 이 포스팅에서 알 수 있는 것들 🙋‍
>
> - scanf 함수
> - 서식문자
> - 배열
> - 암시적 형변환
> - 강제적 형변환
> - 자료형별 메모리크기
> - 실수
> - 연산자
> - 정수와 소수를 함께 연산하기
> - 문자열
> - 전역변수 vs 지역변수

<br>

## scanf 함수
---
- _scanf라는 용어의 뜻이 뭐지?_

	__scan__ + __formatted__ = 스캔(읽다) + 형식(형식을 정해서)

	즉, 사용자의 입력을 읽는데 입력 값의 형식을 지정해 줘야 한다는 것!

	<br>

- _scanf 함수 사용법_

	__scanf("형식", 메모리 주소);__

	형식 부분의 큰따옴표 안에 입력할 데이터의 형식을 지정해줘야 한다.

	메모리 주소는 입력받은 데이터를 메인 메모리의 어디에 저장할지 정해준다.

	즉, 정해준 형식에 맞는 데이터를 입력받아서 지정해 준 메모리 주소에 저장하라는 뜻이다.

	scanf의 메모리 주소 부분은 특별한 경우가 아닌 이상 변수명 앞에 &(앰퍼샌드)를 붙이면 된다.

	> 즉, c언어에서는 변수 이름 앞에 & 기호를 붙이면 해당 변수의 메모리 주소를 뜻함을 알 수 있다.
	>
	> ~~~c 
	> // printf 함수에 &를 붙여서 출력해보면 변수의 값이 나오지 않고 변수 메모리 주소가 출력됨을 확인할 수 있다.
	> printf("%d", &n);
	> ~~~

	입력 받을 데이터가 __문자열(형식이 %s)이라면 메모리 주소부분에 &를 붙이지 않는다.__ --> 붙이면 컴파일 에러가 난다!

	<br>

- _scanf함수는 스페이스 공백을 입력받지 않는다?_

	scanf 함수는 원래 스페이스 공백을 입력받지 않는다. 따라서 스페이스 공백을 입력받고 싶다면 

	~~~c
	// 엔터가 입력될 때까지 그 전의 모든 문자를 입력받는다.
	scanf("%[^\n]c", str);
	~~~ 
	이렇게 작성해야 한다.

	<br>

- _scanf함수로 여러개의 입력 받기_

	scanf 함수 한번으로 여러개의 변수를 입력받기 위해서

	~~~c
	// 변수 a, b, c에 입력을 하되 스페이스나 엔터로 구분하여 입력된다.
	scanf("%d%d%d", &a, &b, &c);


	//이것도 가능하다.
	scanf("%d %d %d", &a, &b, &c);
	~~~

	<br>

- _scanf 함수로 배열의 원소가 int 형인 배열에 입력하기_

	> scanf 함수로 입력한다는 것은 사용자 입력을 받겠다는 것!

	__for문을 사용하여 입력해야 한다!__

	~~~c
	// 배열의 원소가 int 형인 배열의 메모리 주소를 나타낼 때는 &를 꼭 붙여야 한다.
	// 아래 코드로 스페이스 공백으로 입력을 구분할 수도 있고 엔터로도 입력을 구분할 수 있다.
	int isArr[10];
	for(int i = 0 ; i < 10 ; i++){
		scanf("%d", &isArr[i]);
	}
	~~~

- _다른 언어보다 c언어가 빠른 이유?_

	위의 scanf 함수를 사용하기 위해서 우리는 입력 데이터의 형식을 지정해줘야 하고 &기호도 붙여줘야 하고 해야할 것들이 참 많다.

	하지만 파이썬 같은 다른 프로그래밍 언어에서는 입력 형식을 지정해줄 필요가 없다. 이 뿐만 아니라 c언어에서는 프로그래머가 해줘야 하는 문법적인 일이 많은 반면 대부분의 다른 언어들은 c언어보다 해줘야 할 일들이 적다.

	즉, 개발자들은 아주 편하다!

	하지만 c언어는 사람이 컴퓨터에게 어느정도 알려주는 방식이기 때문에 컴퓨터가 자체적으로 해야하는 일이 줄어든다는 장점이 있다. 따라서 c언어는 매우 빠르지만 파이썬은 매우 느리다.

	<br>

## 서식문자
---

- _서식문자란?_

	scanf 함수나 printf 함수에서 입력 or 출력 데이터의 형식을 지정해줄 때 사용하는 문자.

	<br>

- _서식문자의 종류_

	__%f__ : 입력 및 출력할 데이터가 float 자료형 변수일 때 사용

	__%lf__ : 입력 및 출력할 데이터가 double 자료형 변수일 때 사용

	> 💁‍ 더 알아둘 것!
	>
	> %.9f : printf 함수의 서식문자로 사용하면 출력시 소수점 뒤로 아홉번째 자리까지 출력해준다.

	<br>

## 배열
---

- _배열 선언 및 초기화 하기_

	~~~c
	// int 자료형 배열 선언하기
	// 배열 크기가 10이다.
	int arr[10];


	// 배열을 선언과 동시에 초기화하기
	// 10이 출력됨
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
	printf("%d", arr[9]);


	// 배열을 선언과 동시에 초기화 할 경우에는 배열 크기를 지정해 주지 않아도 된다.
	// 배열 크기를 초기화된 원소의 개수라고 판단하기 때문.
	int isArr[] = {1,2,3};


	// 단, 초기화 없이 선언만 할 경우에는 반드시 배열 크기를 명시해줘야 한다.
	// 아래와 같은 코드는 컴파일 에러.
	char isArr[];
	~~~

	<br>

- _배열의 모든 원소를 0으로 초기화 하기_

	~~~c
	int isArr[10] = {};

	~~~

	<br>

- _배열의 특정 인덱스 뒤에 위치한 원소들을 0으로 초기화 하기_

	~~~c
	// isArr 배열의 각 원소들에는  1,4,0,0,0,0,0,0,0,0 이 저장된다.
	// 무조건 인덱스 0부터 명시된 수가 저장되며 나머지 인덱스에는 무조건 0이 저장된다. 
	// 즉, 이 코드는 0,0,0,1,4,0,0,0,0,0 이 아니다.
	int isArr[10] = {1,4};


	// 위와 동작이 같은 코드이다.
	int isArr[10] = {1,4,}

	~~~

	<br>

- _배열을 초기화 하지 않거나 특정 값을 저장해주지 않는다면?_

	특정한 값도 들어가 있지 않고 초기화 되어 있지도 않은 배열의 원소에는 쓰레기 값이 들어간다.

	~~~c

	// 10개 쓰레기 값이 출력되는 것을 볼 수 있다.
	int isArr[10];

	for(int i = 0 ; i < 10 ; i++){
		printf("%d\n", isArr[i]);
	}

	
	~~~

	<br>

## 암시적 형변환
---

__형 변환__ 이라는 것은 변수의 자료형을 다른 자료형으로 바꾸는 행위를 말한다.

영어로는 __casting(캐스팅)__ 이라고 불리기도 한다.

c언어 컴파일러는 어떤 변수에 잘못된 자료형의 데이터가 저장될 경우 그 데이터를 변수 자료형에 맞게 자동으로 변형시킨다. 
	
이것을 __암시적 형변환__ 이라고 한다.

암시적 형 변환의 예를 보면

~~~c
// float 자료형으로 선언된 변수에 int 데이터가 저장된 경우이다.
float isFloat = 3;

// 위 경우에 c 컴파일러는 isFloat 에 3.0이 저장되도록 3 --> 3.0 으로 자동 변형한다.
~~~
	
<br>

## 강제적 형변환
---

- _강제적 형변환이란?_

	위에서 설명한 암시적 형변환은 컴파일러가 자동적으로 변수의 자료형을 바꿔주어 프로그래머가 신경쓰지 않아도 된다.

	하지만 프로그래머가 인위적으로 변수의 자료형을 바꿔주는 행위를 __강제적 형변환__ 이라고 한다.

	<br>

- _강제적 형변환시 주의할 점_

	char 자료형 변수를 int 자료형 변수로 강제 형변환할 경우, 변환된 int 자료형 변수에는 문자의 아스키코드 값(정수)으로 바뀌어 저장된다.

	~~~c
	// int 자료형 변수 isInt 에는 'A'의 아스키코드 값인 65이 저장된다.
	char isChar = 'A';
	int isInt = (int)isChar;


	// int 자료형 변수 a 에는 '5'(숫자 5 아님)의 아스키코드 값인 53이 저장된다.
	// a에 5가 저장되는 것이 아님! 
	char isChar5 = '5';
	int a = (int)isChar5;
	~~~

	<br>

## 자료형별 메모리 크기
---

- _int형 변수의 메모리 크기_

	__4바이트 = 32비트__

	즉, int형 변수에 할당되는 메모리는 32비트이고, 0과 1이 들어갈 수 있는 자리가 32개라는 것!

	따라서 int형 변수에 저장할 수 있는 정수의 범위가 정해져있다는 의미이다.

	<br>

- _float형 변수의 메모리 크기_

	__4바이트 = 32비트__

	<br>

- _double형 변수의 메모리 크기_

	__8바이트 = 64비트__

	> float형 변수를 사용하는 것이 double 형 변수를 사용하는 것 보다 메모리면에서 절약된다.
	>
	> 하지만 소수점 뒤 자리수가 많은 수(정밀한 수)를 표현해야 하는 경우에는 double형 변수를 사용해야 한다.

	<br>

## 실수
---

- _실수란?_

	숫자 중 소수점이 있는 수를 말한다.

	> 😇 float 의 어원
	>
	> float = 떠다니다 = 고정되어 있지 않다.
	>
	> __소수를 표현하는 방식__ 에는 두 가지 방식이 있다.
	> 
	> - __고정 소수점 방식__ : 175.3, 12.6 과 같이 소수점의 위치가 고정되어 있도록 표현하는 방식
	>
	> - __부동 소수점 방식__ : 6.02 X 10^23은 60.2 X 10^22 과 같다. 이와 같이 소수점의 위치가 고정되어 있지 않아도 되도록 표현하는 방식 = 소수점이 고정되어 있지 않다. = __소수점이 떠다닌다.__
	>
	> 위 두 가지 소수 표현 방법 중 컴퓨터는 __부동 소수점 방식__ 을 사용하기 때문에 float 라는 용어를 사용하는 것이다.

	<br>

## 연산자
---

- _+= 연산자_

	\+ 연산자와 = 연산자를 한번에 쓰는 경우 = 를 무조건 뒤에 쓴다.

	~~~c
	sum += num;
	~~~

	<br>

## 정수와 소수를 함께 연산하기
---

- _int / int_

	결과값은 정수로 나온다.

	<br>

- _(double)(int/int)_

	결과값이 소수로 나온다. = 강제 형 변환

	~~~c
	// 3.000000이 출력됨
	int a = 10;
	int b = 3;
	printf("%lf", (double)(a / b));
	~~~

	![01](https://user-images.githubusercontent.com/31889335/57830509-4e87fc00-77ed-11e9-8138-8444782cb377.PNG)

	<br>

- _(double) int / int_

	~~~c
	// 3.333333이 출력됨
	int a = 10;
	int b = 3;
	printf("%lf", (double)a / b);
	~~~

	![02](https://user-images.githubusercontent.com/31889335/57830766-1af9a180-77ee-11e9-9fa8-8b3b90de7c77.PNG)

	<br>

- _ int / (double) int_

	~~~c
	// 3.333333이 출력됨
	int a = 10;
	int b = 3;
	printf("%lf", a / (double) b );
	~~~

	이것도 10 / 3.000000 을 계산해보면 3.333333이 나온다.

	<br>

## 문자열
---

- _문자 vs 문자열_

	__문자__ : 단 한개의 문자
	
	__문자열__ : 문자들의 배열

	> 🤠 문자 vs 문자열의 서식문자
	> 
	> 문자를 나타내는 서식문자 : __%c__
	>
	> 문자열을 나타내는 서식문자 : __%s__

	<br>

- _c언어 문자열에 대한 중요한 것!_

	c언어에는 문자 자료형인 char은 존재하지만 문자열 자료형은 따로 존재하지 않는다!!

	따라서 c언어에서 문자열을 표현하고 싶다면 문자들의 배열을 문자열이라고 표현해야 한다.

	~~~c
	char isArr[10];


	// 입력 서식문자는 %c가 아니라 %s 이다.
	// 문자열 형식으로 입력하겠다는 의미이다.
	// 문자열 형식으로 입력할 때는 & 를 붙이지 않는다.
	// chohee를 입력했다고 가정.
	// 첫 번째 출력 : chohee
	// 두 번째 출력 : c
	// 즉, %s 로 입력해도 문자열 인덱스 각각에 'c' 'h' 'o' 'h' 'e' 'e' 가 입력되는 것이다.
	scanf("%s", isArr);
	printf("%s", isArr);
	printf("%c", isArr[0]);
	~~~

	> c++ 에는 string 이라는 문자열 자료형이 따로 존재한다.

	<br>

- _cstring 헤더파일_

	위와 같이 char 형 문자들의 배열로서 취급되는 c언어 문자열에 적용시킬 수 있는 다양한 함수들이 모여있는 헤더파일이다.

	__string.h__ 라고도 한다.

	cstring 헤더파일에 존재하는 함수들에는 

	- 두 문자열을 합치는 함수

	- 두 문자열 비교 함수

	- 문자열에서 특정 문자 찾는 함수

	- 문자열의 길이를 재는 함수

	등등이 존재한다.

	> https://modoocode.com/76 참고

	<br>


## 전역변수 vs 지역변수
---

- _전역변수 와 지역변수란?_

	C언어에서는 변수가 선언되어 메모리에 자리잡는 위치에 따라서 크게 __전역변수__ 와 __지역변수__ 로 나뉜다!

	<br>

- _지역변수 메모리 위치_

	지역변수는 __스택(stack)__ 이라는 메모리 영역에 자리를 잡는다.

	> 🤯 프로그램이 실행된다는 것은 메인 메모리에 프로그램이 올라간다는 것이다!
	> 
	> 이 때, 실행되는 프로그램마다 메모리 공간이 주어지는데 이 메모리 공간은 또 다시 data 공간, heap 공간, stack 공간 등으로 나뉜다.
	>
	> data, heap, stack 이라는 공간 중 지역변수는 stack 이라는 공간에 할당된다는 의미이다!

	<br>

- _그럼 어떤 변수들이 stack 에 할당되는 지역변수일까?_

	중괄호 안에서 선언된 변수들을 지역변수라고 한다!

	즉, for문 안에서 선언된 변수가 있다면 그 변수는 지역변수이고, stack 공간에 위치한다.

	<br>

- _지역 변수의 중요한 특징_

	지역 변수는 선언된 중괄호 안에서만 사용가능하고 중괄호 밖에서는 사용 불가능하다!

	즉, for문에 선언된 변수는 for문 안에서만 접근가능하고 for문 밖에서는 접근 불가능하다. (for 문 밖에서 for문 안의 변수의 값을 바꾸거나 할 수 없다!)

	<br>


