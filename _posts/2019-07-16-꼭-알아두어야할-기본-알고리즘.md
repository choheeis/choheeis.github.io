---
layout: post
title:  "🎁 꼭! 알아두어야 할 알고리즘들과 자료구조들!"
date:   2019-07-16 18:34:10 +0700
categories: [c++]
---

> [그림으로 배우는 알고리즘](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=85969851) 이라는 책으로 알고리즘을 쉽게 이해해보았다!
>
> ☝️ 알고리즘을 배우는 것은 문제를 풀기 위한 정석을 배우는 것이다. 실력있는 바둑 선수들도 정석대로 수를 놓는 법을 배우듯 문제를 풀기위해 정석을 배우자!

<br>

## 🎁 꼭! 알고 있어야 할 알고리즘들 리스트
---

> 아래 알고리즘들은 차차 공부한 후, 따로 포스팅하여 링크로 걸어두겠습니다!

- _계산에 자주 사용되는 알고리즘들_

    유클리드 호제법

    가우스 소거법

    사다리꼴의 법칙

    다이스트라 알고리즘

    에라토스테네스의 체

    <br>

- _정렬에 사용되는 알고리즘들_

    단순 선택 정렬

    단순 교환 정렬(버블 정렬)

    단순 삽입 정렬

    셸 정렬

    합병 정렬

    퀵 정렬

    <br>

- _검색에 사용되는 알고리즘들_

    선형 검색(리니어 서치)

    이진 검색(바이너리 서치)

    <br>

- _문자열 패턴 매칭에 사용되는 알고리즘들_

    단순 문자열 일치 알고리즘

    KMP 알고리즘

    BM 알고리즘

    <br>

## 📚 꼭! 알고 있어야 할 자료구조들!
---

- _배열_

    데이터를 빈틈없이 나열한 자료구조이다.

    직선형(1차원 배열), 직사각형형(2차원 배열), 직육면체 형(3차원 배열) 등이 있다.

    <br>

- _리스트_

    데이터를 순서대로 나열한 자료구조이다.

    배열과 같이 순서가 있는 데이터를 저장하고 관리한다.

    하지만 배열과 다르게 데이터들이 화살표로 서로 연결되어 있어 데이터들이 떨어진 장소에 위치해도 된다는 점이 장점이다.

    ![리스트](https://user-images.githubusercontent.com/31889335/61299760-ab1e8c00-a81b-11e9-84a3-4f27706bb1d9.PNG)

    리스트는 크게 두 가지 종류로 나뉜다.

    - __단방향 리스트__ 

        단방향 리스트의 각 요소에는 2가지 항목이 들어있는데 데이터와 다음 요소를 가리키는 포인터이다.

        이 때, 포인터가 위 그림에서 화살표 역할을 하는 친구이다.

        이 포인터는 다음 요소가 어디에 있는지 __위치정보__ 가 저장되어 있다.

        또한, 단방향 리스트의 마지막 요소의 포인터에는 이제 다음 요소가 더이상 없다는 뜻의 종료 정보가 저장되어 있다.

        여기에 더불어 단방향 리스트에는 HEAD 포인터라는 특별한 포인터가 따로 존재하는데 여기에는 리스트의 맨 처음 요소의 위치 정보가 저장되어 있다.

        ![단방향리스트](https://user-images.githubusercontent.com/31889335/61359643-b8895400-a8b7-11e9-89bc-44f64bd6213d.PNG)

        만약, 단방향 리스트에 아무 데이터가 저장되어 있지 않아 리스트가 비어있는 경우, HEAD 포인터에는 종료 정보가 저장된다.

        <br>

    - __양방향 리스트__

        양방향이라는 뜻과 같이, 이 리스트는 화살표 방향이 두 방향으로 존재하는 리스트이다.

        따라서 리스트의 각 요소에는 데이터, 다음 요소를 가리키는 포인터 외에도 이전 요소를 가리키는 포인터가 추가로 포함되어 있다.

        이전 요소를 가리키는 포인터에는 이전 요소가 어디에 있는지에 대한 위치 정보가 저장되어 있다.

         또한, 단방향 리스트에서 HEAD 포인터가 존재헀던 것과 같은 맥락으로, 양방향 리스트는 HEAD 포인터와 TAIL 포인터를 둘 다 가지고 있다. 

         양방향 리스트에서 HEAD 포인터에는 첫 번째 요소의 위치 정보가 저장되어 있으며, TAIL 포인터에는 마지막 요소의 위치정보가 저장되어 있다.

         만약, 리스트가 비어있다면 HEAD, TAIL 포인터에 모두 종료 정보가 저장된다.

         ![양방향리스트](https://user-images.githubusercontent.com/31889335/61360167-d4d9c080-a8b8-11e9-8863-9e3124737ef3.PNG)

        <br>

    > 👀 배열과 리스트를 비교해보자!
    >
    > __1. N번째 요소를 찾아야할 때__ 리스트보다는 배열을 사용하는 것이 더 편리하다!
    >
    > --> 배열은 index 값을 통해 N번째 요소를 즉시 찾을 수 있지만 리스트는 N번째 값을 찾기 위해 첫번째 요소부터 순서대로 N번째 요소까지 확인하여야 한다.
    > 
    > __2. 데이터를 중간지점에 삽입해야 할 때__ 배열보다는 리스트를 사용하는 것이 더 효율적이다!
    >
    > --> 배열의 중간에 새로운 데이터를 삽입하기 위해서는 삽입 위치 다음에 존재하는 모든 요소들을 한칸씩 뒤로 이동시켜야 한다. 만약 1000개의 요소들을 한칸씩 뒤로 이동시켜야 한다면 시간 소모가 커질 것이다!
    >
    > 하지만 리스트의 중간에 새로운 데이터를 삽입한다면 삽입 요소의 바로 직전 요소가 가지는 '다음요소 위치 정보' 와 삽입 요소의 '다음요소 위치 정보'만 수정하면 되므로 배열보다 더 효율적이다.
    >
    > __3. 중간지점의 데이터를 삭제해야 할 때__
    > 
    > 데이터를 중간지점에 삽입하는 경우와 마찬가지로 배열보다 리스트를 사용하는 것이 더 효율적이다!
    >
    > 배열의 중간 데이터를 삭제한다면 삭제 위치 다음의 모든 요소들을 한칸씩 앞으로 이동시켜야 한다.
    >
    > 하지만 리스트 중간 지점의 데이터를 삭제한다면 위치정보만 수정하면 된다.

    <br>

- _스택(Stack)_

    책상 위에 책을 쌓듯 데이터를 저장하고 관리하는 자료구조이다.

    일반적으로 쌓여있는 책은 가장 위쪽부터 꺼내는 것이 안전하듯이 스택도 가장 위쪽 데이터부터 꺼낼 사용할 수 있다.

    즉, 스택 자료구조를 사용하면 데이터를 넣은 순서와 반대의 순서로 데이터를 꺼낼 수 밖에 없다.

    
    ![스택](https://user-images.githubusercontent.com/31889335/61307781-eb850680-a829-11e9-82ea-6a90a10ed922.PNG)

    스택 자료구조를 사용하여 데이터를 관리할 때는 아래 두 가지 작업을 알아두어야 한다.

    - __PUSH__ : 스택 자료구조에 데이터를 넣는 작업

    - __POP__ : 스택 자료구조에서 데이터를 꺼내는 작업

    <br>

- _큐(Queue - 대기행렬)_

    계산대에 먼저 줄을 선 손님부터 계산을 해주듯 데이터를 저장하고 관리하는 자료구조이다.

    즉, 큐 자료구조를 사용하면 먼저 들어온 데이터부터 꺼낼 수 있다.

    > 운영체제 수업 때 프로세스 레디 큐 구조를 떠올리자!

    ![큐](https://user-images.githubusercontent.com/31889335/61307642-a7920180-a829-11e9-915d-e74543937321.PNG)

    <br>

- _트리_

    나뭇 가지가 나뉘듯 퍼져 나가는 자료구조이다.

    ![트리](https://user-images.githubusercontent.com/31889335/61307349-22a6e800-a829-11e9-9305-ff4f9b55f2c8.PNG)

    <br>
