---
layout: post
title:  "알고리즘 책 읽고 공부하기 2일차 <탐색 알고리즘들>"
date:   2019-03-14 18:34:10 +0700
categories: [algorithm]
---


> <알기 쉬운 알고리즘, 양성봉, 생능출판> 책으로 공부한 알고리즘

<br>


## ✔️  순차 탐색 알고리즘
--- 


-  숫자 배열 중 특정한 숫자를 찾되 배열의 모든 원소와 하나하나 비교하면서 찾는 알고리즘!

	배열의 크기가 10인 int 형 배열이 있다고 하자. 배열의 원소들 중 내가 원하는 정수가 있는지 찾으려면 어떻게 해야할까?
	
	~~~c
		#include<stdio.h>

		 int main(){
			 int arr[10] = {5, 20, 61, 4, 3, 16, 53, 2, 74, 30};
			 int is_there = 53; 	// 배열 속에서 찾고자 하는 숫자

			 for(int i = 0 ; i < 10 ; i++){
				 if(arr[i] == in_there){	
					 printf("is_there's index is : %d\n", i);
				 }else{
					 continue;
				 }
			 }
		 }


	~~~

	_for문을 사용해서 인텍스 0 부터 인덱스 9까지 해당 인덱스의 숫자와 찾고자 하는 숫자가 같은지를 비교하고, 같으면 for문을 빠져나오며, 같지 않으면 for문을 계속 실행시킨다!_ 

	<br>

## 〽️ 이진 탐색 알고리즘
--- 


- 찾으려는 원소가 배열을 반절로 나누었을 때 오른쪽에 속하는지 왼쪽에 속하는지를 반복적으로 파악하면서 찾는 알고리즘!

	배열의 크기가 10인 int형 배열이 오름차순으로 정렬되어있다고 하자. 배열의 원소들 중 내가 원하는 정수가 있는지 찾으려면 어떻게 해야할까?

	~~~c
	#include<stdio.h>

	int main(){
		int arr[10] = {2, 12, 15, 30, 41, 42, 53, 75, 90, 99};
		int is_there = 75;

		int first = 0;	// 배열의 첫 인덱스
		int last = 9;	// 배열의 마지막 인덱스
		int mid = 0;

		while(first <= last){
			mid = (first + last) / 2;
			if(arr[mid] == is_there){
				printf("is_there's index is : %d\n", mid);
				break;		
			}else if(arr[mid] < is_there){
				first = mid + 1;
			}else{
				last = mid -1;
			}
		}
	}

	~~~
	_이렇게 first와 last의 범위를 좁혀가면서 찾고자 하는 원소를 찾는 것이다_
	

	<br>

##  📐 보간 탐색 알고리즘
---

-  거스름돈은 동전으로 받아야 한다면 어떻게 해야 가장 적은 개수의 동전으로 받을 수 있을까?

	~~~
	<풀이>

	만약 730원의 거스름돈을 받아야 할 때 가장 작은 수의 동전을 받기 위해 생각해봐야 하는 것은 730원 내에 존재하는 가장 큰 액수의 동전이 있는지를 생각해보는 것이다

	730원 내에서 가장 먼저 생각나는 동전은 500원 1개이다. 그럼 남은 230원 중 생각나는 동전은 100원 2개이다. 마지막 30원에서는 10원 3개가 생각난다
	~~~

	이렇게 어떤 액수를 넘지 않는 한도에서 가장 큰 수를 계속해서 선택하는 알고리즘을 _그리디 알고리즘(greedy = 탐욕)_ 알고리즘이라고 한다!

	<br>

## ✏️ 한붓그리기
---
- ### 종이에서 연필을 떼지 않고 모든 선분을 한 번만 지나서 다시 출발점으로 돌아오는 한붓 그리기를 해보자!
	~~~
	<풀이>


	~~~
	