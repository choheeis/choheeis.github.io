---
layout: post
title:  "운영체제3"
date:   2019-04-13 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>
> _3강 - Processes_
>
> _🙋 3강에서 설명할 수 있어야 할 것들 🙋_
>
> - 프로세스의 개념
> - 프로세스 관리 기법
> - 프로세스간 통신 기법

<br>

##  🚿 프로세스(Process)
---

- _프로세스란?_

	프로그램들 중 실행되고 있는 프로그램을 프로세스라고 한다!

	종종 task 라는 용어를 들을 수 있는데 이 task도 프로세스를 말하는 것이다.

	<br>

- _프로세스에 포함되는 것들_

	![운영체제11](https://user-images.githubusercontent.com/31889335/56074981-1a887800-5df6-11e9-8626-e35ffdf7bd41.PNG)

	위 그림은 프로세스가 실행될 때 생기는 Address(주소) 공간이다. 

	- __text 부분__ = 프로그램 코드가 들어가는 부분

	- __data 부분__ = 전역변수, static 변수들이 들어가는 부분

	- __Stack 부분__ = 일시적인 데이터가 들어가는 부분( 함수의 매개변수, 리턴되야하는 주소값이나 전역변수 등)

	즉, 함수가 호출되면 스택이 늘어나고, 함수가 끝나면 스택이 줄어든다!

	- __Heap 부분__ = 런타임동안 동적으로 할당되는 메모리가 들어가는 부분 ( 힙 영역은 늘어나기도 하고 줄어들기도 한다. )

	- 

	- 이때, 텍스트와 데이터 부분은 크기가 변하지 않고 정해져 있다.

	<br>

## 😐 프로세스 상태
---

- _프로세스가 실행되면 프로세스의 상태가 바뀐다!_

	총 5개의 프로세스의 상태가 존재한다.

	__New__ 상태 (프로세스가 생성될 때의 상태)

	__Running__ 상태 (프로세스가 실행되고 있는 상태)

	__Waiting__ 상태 (running 상태는 아닌데 어떤 이벤트가 발생하기를 기다리는 상태이다. 즉, cpu가 할당되기 전에 이벤트를 기다리고 있는 상태이다. 이벤트를 받아야 CPU 할당을 받을 수 있다.)

	blocked 또는 sleep 이라고도 한다.

	__Ready__ 상태 (CPU가 할당되기를 기다리고 있는 상태)

	__Terminated__ 상태 (프로세스가 종료된 상태)

	![운영체제12](https://user-images.githubusercontent.com/31889335/56075083-c7172980-5df7-11e9-92c5-d24fa5dcaefd.PNG)

	위 그림은 프로세스의 상태가 변하는 모습을 다이어그램으로 나타낸 그림이다.

	새로운 프로세스가 생성되면 ready 상태가 된다. 

	ready 상태에서 선택되어 CPU가 할당된 프로세스는 __스케쥴러 디스패치(scheduler dispatch)__ 가 정한 순서대로 running 상태로 바뀐다.

	프로세스는 cpu를 할당받아서 running 하는데 이때 혼자만 계속 cpu를 사용할 수 없다. 그래서 __타임 슬라이스(time slice)__ 라고 하는 정해진 시간만큼 cpu를 쓰다가 다시 ready 상태의 순서 중 맨 뒤로 돌아간다. 

	만약 프로세스가 입출력을 수행해야 하는 프로세스라면 I/O 이벤트에 따라서 waiting 상태로 간다. I/O 이벤트가 완료되면 다시 ready 상태로 간 후, cpu를 다시 할당받아서 프로세스 작업을 이어서 하는 것이다.

	이 과정을 반복한 후 유저가 프로그램을 종료하면 프로세스가 종료된다.

	<br>

## ♒️ 프로세스 Control 블록
---

- _프로세스 Control 블록이란?_

	데이터를 관리하기 위한 메타데이터가 저장된 공간이다.

	![운영체제13](https://user-images.githubusercontent.com/31889335/56075245-51f92380-5dfa-11e9-9dbd-934414e1a788.PNG)

	프로세스 Control 블록은 위와 같이 되어 있는데 PCB는 지금 실행중인 프로세스의 정보를 담고 있다.

	![운영체제14](https://user-images.githubusercontent.com/31889335/56075258-8a006680-5dfa-11e9-8e77-25b6936d2bbc.PNG)

	PCB의 구조를 자세히 살펴보면 이와 같은데 해당 프로세스의 ID와 프로세스의 상태, 프로세서 counter

	<br>

## 📜 프로세스 스케줄링 큐(Queue)
---

-  프로세스 스케줄링 큐에는 __레디(ready) 큐__ 와 __디바이스(device) 큐__ 가 있다.

- _레디 큐_

	메인 메모리에 올라가 있으면서 수행을 기다리고 있는 모든 프로세스들의 집합을 말한다.

	큐에 있다고 하는 것은 순서를 지켜 한 줄로 기다리고 있음을 의미한다.

	<br>

- _디바이스 큐_

	어떤 I/O 디바이스의 이벤트를 기다리고 있는 프로세스들의 집합이다.

	프로세스들은 레디 큐와 디바이스 큐 사이에 왔다갔다 하는데 즉, 디바이스 큐에서 나와서 레디 큐로 들어갈 수도 있다는 것이다.

	![운영체제15](https://user-images.githubusercontent.com/31889335/56075514-e6fe1b80-5dfe-11e9-8125-c85c9f92a6e3.PNG)

	위 그림을 통해 레디 큐와 디바이스 큐로 프로세스가 이동하는 모습을 볼 수 있다.

	<br>

## 📝 스케줄러(Scheduler)	
---

- _CPU 스케줄러_

	스케줄러는 CPU 스케줄러를 말한다.

	CPU 스케줄러는 현재 수행되고 있는 프로세스가 있는데 타임슬라이스에 의해 이 프로세스가 중단되면 그 다음에 어떤 프로세스를 선택하여 CPU를 할당해 주어야 하는지를 결정하는 일을 한다.

	일반적으로 CPU 스케줄러는 레디 큐에 있는 것 중 제일 앞에 있는 것을 선택한다. 

	하지만 맨 앞에 있는 프로세스에게 CPU를 할당해주는 것이 항상 좋은 방법일까?

	CPU 스케줄러가 다음에 수행될 프로세스를 선택하는 기준은 프로세스의 종류가 어떤 것이냐 이다.

	프로세스는 2가지로 분류될 수 있다.

	__I/O bound 프로세스__ = CPU 연산보다는 I/O 작업을 하는데 시간을 더 많이 사용하는 프로세스

	__CPU bound 프로세스__ = CPU 연산을 하는데 시간을 더 많이 사용하는 프로세스

	이 두 종류의 프로세스들이 레디 큐에서 CPU 할당을 기다리고 있다면 이들 중 CPU 스케줄러는 어떤 프로세스를 먼저 선택해야 할까?

	I/O bound 프로세스를 먼저 선택하여 CPU를 먼저 할당해 주는 것이 좋다.

	왜냐하면 I/O 작업은 CPU의 처리가 오래 걸리지 않지만 I/O 자체 작업의 시간이 더 오래 걸린다. 

	따라서 I/O bound 프로세스가 CPU를 요구하는 것을 얼른 들어주고 I/O 자체 작업을 하도록 넘겨주는 것이 좋다.

	만약 CPU 사용시간이 긴 CPU bound 프로세스를 먼저 선택하면 I/O bound 프로세스는 잠깐의 CPU 연산을 하기 위해 CPU bound 프로세스가 끝날 때까지 오래 기다려야 하는 불상사가 발생한다.

	<br>


## 🚁 Context Switch 
---

- 여러 프로세스들이 CPU를 번갈아 사용할 때마다 막 마쳐진 프로세스의 상태를 저장해야 하고, 이 프로세스가 다시 선택되어 질 때 전에 저장해 놓은 상태를 불러와야 한다.

- _CPU Switch_

	CPU는 이 프로세스에서 저 프로세스로 옮겨진다.  

	<br>

## 👍 👎 프로세스의 생성과 종료에 대해서
---

- _프로세스의 생성_

	부모 프로세스가 자식 프로세스를 생성하는 구조이다. 즉, 프로세스의 탄생 구조는 __트리 구조__ 이다.

	_자식 프로세스는 자원을 필요로 한다_

	자식 프로세스는 자신의 수행을 위해 CPU 같은 리소스를 필요로 하는데 이와 같은 리소스를 운영체제가 직접 할당해 줄 수도 있고, 부모 프로세스가 공유해 줄 수도 있다.

	_부모와 자식 프로세스 간의 리소스 공유_

	부모와 자식 프로세스간에 __모든__ 리소스를 공유할 수도 있고, 리소스의 __부분__ 만을 공유할 수도 있으며 공유하지 __않을__ 수도 있다.

	_프로세스 실행_

	부모와 자식 프로세스가 동시에 실행될 수도 있고, 부모 프로세스가 자식 프로세스가 먼저 종료될 때까지 기다릴 수도 있다.

	_주소 공간_

	앞에서 프로세스가 실행되면 주소 공간이 생성된다고 했다. 

	자식 프로세스는 부모의 주소 공간을 복사한다. 이때, 복사한다는 것이 주소 공간의 내용까지 모두 복사하는 것이 아니라 주소 공간의 구조만 복사한다는 것이다. 그러면 크기가 똑같은 주소 공간이 생성되는데 자식 프로세스가 이 곳을 자신의 주소 공간으로 사용한다.

	_프로세스 실행 과정_

	프로세스가 하나 생성되면 처음에는 운영체제 커널이 PCB를 하나 만들어 준다. 또, 주소 공간도 할당해 준다. 그 후 바이너리 프로그램을 그 위에 로드하고( = 올리고) 프로그램을 초기화 시킴으로써 프로그램을 실행시킨다.

	유닉스 운영체제의 경우에는 fork 라는 것을 통해서 새로운 프로세스를 하나 만든다. 

	유닉스에서는 fork가 새로운 프로세스를 만드는 유일한 방법이다. 그 다음 부모의 PCB를 복사한다.

	그 다음 execve 라는 시스템을 호출하여서 바이너리 프로그램을 올리고 초기화시킨다.

	<br>

- _프로세스 종료_

	자식 프로세스는 자신의 가장 마지막 상태를 수행한 후, 운영체제에게 자신이 종료되어도 되는지를 물어본다.

	그 후, 자식 프로세스가 종료되면서 자신을 기다리고 있는 부모 프로세스에세 자신의 상태값을 return(반환)한다.

	이 상태값은 0 부터 255 까지 숫자 중 하나이다.

	그러면 wait()라는 시스템 콜에 의해 기다리고 있는 부모의 wait() 함수가 그 상태값을 받는다. 

	이때 만약 자식 프로세스가 종료될 때까지 부모 프로세스가 기다리고 있지 않다면 이 프로세스를 __좀비 프로세스__ 라고 한다.

	반대로 부모 프로세스가 자식 프로세스를 기다리지 않고 그냥 종료되어 버린 경우 해당 자식 프로세스를 __orphan(고아)__ 라고 한다.

	wait()를 통해 부모 프로세스가 기다린다는 것은 자식 프로세스가 종료되면 그 상태를 받아 부모가 뒤처리를 하겠다는 의미이다.
	
	좀비 프로세스는 정상적이지 않은 프로세스이지만 결국에는 메모리를 가지고 있기 때문에 좀비 상태가 많아지면 자원낭비가 된다. 그렇기 때문에 좀비 상태가 된 프로세스는 어느 정도 시간이 지나면 사라진다.

	![운영체제16](https://user-images.githubusercontent.com/31889335/56077311-96de8380-5e15-11e9-81ee-fbecf9d08f70.PNG)

	위 그림을 보고 흐름을 파악할 수 있을 것이다.

	<br>

## 👬 프로세스들의 협력	
---

- Cooperate 프로세스라고 하는 프로세스들 간에 서로 영향을 주고 받아 협력하는 프로세스들이 있는 반면, 서로에게 영향을 주지 않는 독립적인 프로세스도 있다.

- _프로세스들끼리 협력하면 좋은 점_

	서로 파일 같은 정보를 공유할 수 있다.

	연산 속도를 증가시킬 수 있다.

	시스템 함수들을 분리하여 모듈화해서 사용할 수 있다.

	<br>

## 🌞 프로듀서와 고객 프로세스
---

- 프로듀서 프로세스는 고객 프로세스에 의해 소비된 정보를 생산한다.

	<br>

## 🎌 동기화(Synchronization)
---

- 


