---
layout: post
title:  "알고리즘 스터디 <분할 정복 알고리즘>"
date:   2019-04-01 18:34:10 +0700
categories: [algorithm]
---


> <알기 쉬운 알고리즘, 양성봉, 생능출판> 책으로 공부한 알고리즘

<br>


## 🌈 분할 정복 알고리즘이란?

---

- _Divide and Conquer_

분할 정복 알고리즘은 영어로 divide and conquer 이다. 즉, "나눠서 정복하다" 라는 의미이다.

>분할 정복은 실제로 나폴레옹이 전쟁을 할 때 사용했던 방법이라고 한다. 적 전체를 한번에 공격하지 않고, 반절을 먼저 공격하고 나머지 반절을 이후에 공격하는 전략으로 승리하게 되었다.

분할 정복 알고리즘의 기본 개념은 __주어진 문제의 입력을 분할하여 문제를 해결(=정복)하는 방식__ 의 알고리즘이다.

입력을 분할!!

분할된 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산하고, 분할되어 나온 해들을 다시 취합하여 원래 문제의 해를 얻는다.

즉, 입력을 분할하여 나오는 결과는 __부분문제__ 가 되고, 이 부분문제의 해를 __부분해__ 라고 한다.

이때, 부분문제에 동일한 알고리즘을 적용시켜야 하는데 이 말은 즉슨, 작게 나눈 문제의 성격이 원래 문제랑 똑같다는 것이다!!

그리고 부분문제는 더 이상 분할할 수 없을 때까지 계속 분할해야 한다. 제일 좋은 것은 입력 크기가 1이 될 때까지 분할 하는것~!

분할 정복 방법을 사용했을 때 장점은

__입력 크기가 작아진다__ 라는 것!

<br>

## 🚩 입력크기가 n 일 때 총 몇 번 분할하여야 입력크기가 1이 될까?

---

만약 문제를 3문제로 나누면 입력크기가 반절로 줄어드는 분할 정복 알고리즘이 있다고 하면,

![알고리즘1](https://user-images.githubusercontent.com/31889335/55710035-a714ee00-5a24-11e9-9139-5e92f5267fc6.PNG)

위와 같이 그림으로 나타낼 수 있다.

입력크기는 k번 분할하면 n/2^k 개로 줄어들게 되는데 이 수가 1이 되게 하는 식을 풀면

n/2^k = 1 로부터 k = log2(n)임을 알 수 있다.

하지만 분할 정복 알고리즘에서 제일 중요한 것은 입력 크기를 줄이는 것이 아니라 결국에는 부분해를 찾는 알고리즘을 짜는 것이다!!

<br>

## 💊 합병 정렬 알고리즘
---
> 분할 정복 알고리즘은 여러 유형이 있는데 분할되는 부분문제의 수와 부분문제의 입력 크기에 따라서 유형이 나뉘다.

합병 정렬을 영어로 하면 Merge Sort 라고 한다. 즉, 합쳐서 정렬하라는 것이다.

합병 정렬은 __문제가 2개의 부분문제로 분할되고 입력 크기가 1/2로 감소__ 하는 분할 정복 알고리즘이다.

분할 정복 알고리즘이므로 합병 정렬 알고리즘도 각각의 부분문제를 재귀적으로 호출하여 풀어야 한다.

__합병이란 2개의 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것이다.__ 

예를 들어,

![알고리즘2](https://user-images.githubusercontent.com/31889335/55730437-291c0b80-5a53-11e9-956b-b324005e36d2.PNG)

위와 같은 그림에서 정렬된 배열 A와 B를 합치는 것이 합병정렬의 예이다.

즉, 위와 같은 합병 정렬은 주로 n개의 정수를 정렬하라는 문제에서 사용된다.

예를 들어 

![알고리즘3](https://user-images.githubusercontent.com/31889335/55732384-d8a6ad00-5a56-11e9-895b-0adbeb2e34fb.PNG)

위 그림을 보면 알 수 있듯이, 정렬되지 않은 배열을 2문제로 나누어 입력크기가 1이 될 때까지 나눈다. 

그 후, 정렬하면서 합친다!

위 그림을 보고 합병 정렬 알고리즘의 재귀함수 부분을 간단한 코드로 작성해보면

~~~c
void merge_sort(int list[], int left, int right){
    int mid;

    if(left < right){
        mid = (left + right) / 2;
        merge_sort(list, left, mid);
        merge_sort(list, mid + 1, right);
        merge(list, left, mid, right);
    }
}

~~~

// left 는 정렬되지 않은 배열 list의 맨 왼쪽 인덱스이다.

// right 는 배열 list의 맨 오르쪽 인덱스이다.

// 재귀호출이 2번 되는 모습을 볼 수 있다.

_합병 정렬의 시간 복잡도_

합병 정렬에서 기본 연산자는 left와 right 의 크기를 비교하는 비교연산자이다.

정렬되지 않은 배열을 분할하는 부분의 시간 복잡도는 O(1) 이다. 왜냐하면 입력크기가 많아도 반절로 나누는 것은 무조건 한번이기 때문이다....?

하지만 합병하는 순간에는 시간복잡도가 입력크기에 영향을 받는다.

입력 크기가 2인 두 개의 배열을 합병한다고 하면 총 4개의 숫자를 비교해야 하고, 입력 크기가 3개인 두 개의 배열을 합병한다고 하면 총 6개의 숫자를 비교해야 하기 때문이다. 


<br>

## 🎃 퀵 정렬 알고리즘
---

퀵 정렬은 영어로 Quick Sort 라고 한다. (Quick = 빨리)

퀵 정렬은 분할 정복 알고리즘에 속하지만 실제로는 정복 후 분할하는 알고리즘이다.

퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태이다.

_퀵 정렬의 아이디어_

피봇(pivot)이라고 불리는 배열의 한 원소를 선택하고 이 피봇을 기준으로 피봇보다 작은 수는 왼쪽에, 피봇보다 큰 수는 오른쪽에 위치하도록 분할하는 것이다. 

즉, 피봇이 어떤것이냐에 따라서 왼쪽 오르쪽의 개수가 동일하지 않다. 

퀵 정렬은 분할된 부분문제들에 대하여 위와 똑같은 과정을 재귀적으로 수행하여 정렬한다.

단, 피봇은 분할된 왼쪽이나 오른쪽 부분에 포함되지 않는다.

퀵 소트의 재귀함수 부분의 코드를 살펴보면,

~~~c
void quick_sort(int list[], int left, int right){

    if(left < right){
        이 부분에 배열에서 피봇을 선택하여 피봇을 맨 처음 인덱스와 자리를 바꾸고, 피봇과 배열의 각 원소들을 비교해서 피봇의 왼쪽, 오른쪽에 배치하는 코드를 작성한다.

        quick_sort(list, left, p-1);
        quick_sort(list, p+1, right)
    }
}
~~~

// p는 피봇의 인덱스이다.

quick_sort(list, 0, 11)가 수행되는 과정을 살펴보면

![KakaoTalk_20190409_010915583](https://user-images.githubusercontent.com/31889335/55739547-3a214880-5a64-11e9-9fdc-318a786f4cae.jpg)
![KakaoTalk_20190409_010929297](https://user-images.githubusercontent.com/31889335/55739559-3ee5fc80-5a64-11e9-9ab5-fbf6f9de1055.jpg)

이다.

마지막 문단에서 알 수 있듯이, 퀵 소트는 pivot을 무엇으로 선택하느냐에 따라 재귀함수를 더 호출하냐 덜 호출하냐가 달려있다!

즉, 퀵 소트의 성능은 피봇이 좌우한다는 것이다.

만약 피봇으로 가장 작은 수나 가장 큰 수가 선택되어 버리면 한 부분으로 치우치는 분할이 생겨버리는 경우도 있다.
이런 경우, 퀵 소트의 시간 복잡도는 최악이 된다.

_피봇 선택하는 방법_

따라서 피봇이 어떤 원소이냐에 따라서 퀵 소트의 성능이 달라지기 때문에 피봇을 잘 선택해야 한다.

일반적으로 퀵 소트에서 피봇을 선택하는 방법은 2가지이다.

    1. 랜덤하게 선택한다.
    2. 가장 왼쪽 숫자, 가장 오른쪽 숫자, 중간 숫자 이 3개의 숫자 중 중간값을 피봇으로 선택한다.

    2번은 무슨말이냐면 만약 정렬되지 않은 배열이

    31 17 42 9 1 23 18 11 26 

    이라고 하면 가장 왼쪽 숫자는 31, 가장 오른쪽 숫자는 26, 중간 숫자는 1이다. 이 31, 26, 1 중 중간값은 26이므로 피봇은 26이 된다는 뜻이다.





 

