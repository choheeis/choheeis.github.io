---
layout: post
title:  "합병정렬알고리즘"
date:   2019-05-02 18:34:10 +0700
categories: [algorithm]
---


> 배열의 원소들을 정렬하는 알고리즘 중 합병 정렬 알고리즘에 대해서 알아보장
>
> _참고 자료_
> https://zeddios.tistory.com/38

<br>


## 🔗 합병 정렬 알고리즘
---

- 배열의 원소를 정렬하는 알고리즘 중 하나인 __합병 정렬 알고리즘__ 을 공부했다.

	백준 2751번(수 정렬하기 2) 문제를 풀기 위해 합병 정렬 알고리즘을 사용해야 했다! 

	(백준 2751번 문제)
	https://www.acmicpc.net/problem/2751

	> 알고리즘 수업시간에 배우긴 했지만 시험을 위해서 암기하면서 공부한 수준이라 문제를 풀기 위해서는 다시 공부할 필요가 있었다..

	<br>

- _합병 정렬 알고리즘이 배열을 정렬하는 방법_

	일단, 합병 정렬 알고리즘은 배열을 분할하기 때문에 분할 정복 알고리즘에 속한다.

	합병 정렬 알고리즘이 동작하는 과정을 바로 알아보자!

	![합병정렬1](https://user-images.githubusercontent.com/31889335/57060023-c08f1a00-6cf2-11e9-9712-ada4eacfda6e.PNG)

	위 그림과 같이 합병 정렬은 일단 정렬되지 않은 처음 배열을 반으로 쪼개는데 배열의 크기가 1이 될 때까지 계속 쪼갠다.

	위 그림의 배열이 크기가 1이 될 때까지 쪼개지면

	![합병정렬2](https://user-images.githubusercontent.com/31889335/57060112-31cecd00-6cf3-11e9-9e40-8f37ee49d77d.PNG)

	이렇게 된다

	합병 정렬 알고리즘은 이렇게 다 쪼개고 난 뒤 다시 두 개씩 거슬러 올라가면서 합치는데 합치는 과정에서 정렬을 하면서 합친다!

	어떻게 정렬을 하면서 합칠까?

	![합병정렬3](https://user-images.githubusercontent.com/31889335/57060377-2d56e400-6cf4-11e9-8818-30192dced08e.PNG)


	위 그림처럼 쪼개진 두 수를 비교해서 작은 수를 앞에 놓는다. 정렬했으면 합친다!

	그럼 이렇게 정렬된 두 배열을 또 비교해서 합치면 4개의 원소가 정렬되어 합쳐진 배열을 얻을 수 있다!

	그런데 비교할 원소가 2개였을 때는 그냥 두 원소의 크기를 비교해서 작은것을 앞에 놓으면 됬지만 비교 원소가 4개일 때는 어떻게 비교해야 할까?

	![합병정렬4](https://user-images.githubusercontent.com/31889335/57061132-cdae0800-6cf6-11e9-9c7f-71596c721a02.PNG)

	일단 위 그림처럼 각 배열의 첫 번째 원소를 크기비교하여 작은 수를 새로운 배열의 첫 번째 원소로 넣는다.

	그 다음은

	![합병정렬5](https://user-images.githubusercontent.com/31889335/57061238-1a91de80-6cf7-11e9-9201-f849bc4dd3ab.PNG)

	이렇게 5와 9를 비교하여 더 작은 수를 새로운 배열의 두 번째 원소로 넣는다!

	![합병정렬6](https://user-images.githubusercontent.com/31889335/57061306-4ca34080-6cf7-11e9-9456-83a3a13d9286.PNG)

	그 다음은 10과 9를 비교하여서 작은 수인 9를 새로운 배열의 세 번째 원소로 넣고, 마지막 남은 10을 마지막 원소로 넣는다!

	![합병정렬7](https://user-images.githubusercontent.com/31889335/57061354-7eb4a280-6cf7-11e9-88a0-ff9f44342d84.PNG)

	그럼 이렇게 4개의 원소가 정렬된 새로운 배열이 얻어진다!!

	그럼 또 다시 4개의 원소를 가지는 정렬된 배열 두 개를 비교해서 새로운 배열(원소 8개)을 만들어야 하는데 이 때도 위와 같은 방법으로 하면 된다.

	여기까지가 합병 정렬 알고리즘이 배열을 정렬하는 방법이다.

	<br>

## ✏️ 합병 정렬 알고리즘을 c언어로 구현하기
---

- 정렬되지 않은 배열 {4, 2, 10, 6, 9, 46, 7, 28} 을 합병 정렬 알고리즘을 이용해서 정렬해보자.

	~~~c
	#include<stdio.h>
	int list[8] = {4,2,10,6,9,46,7,28}; 
	int sort[8];

	//정렬하면서 합치는 함수
	void merge(int arr[], int left, int middle, int right){
		int sortPivot = left, leftArrPivot = left, rightArrPivot = middle + 1;
		
		while(leftPivot <= middle && rightPivot <= right){
			if(arr[leftArrPivot] < arr[rightArrPivot]){
				sort[sortPivot] = arr[leftArrPivot];
				leftArrPivot++;
			}else{
				sort[sortPivot] = arr[rightArrPivot];
				rightArrPivot++;
			}
			sortPivot++;
		}
		
		while(leftArrPivot <= middle){
			sort[sortPivot] = arr[leftArrPivot];
			sortPivot++;
			leftArrPivot++;
		}
		
		while(rightArrPivot <= right){
			sort[sortPivot] = arr[rightArrPivot];
			sortPivot++;
			rightArrPivot++;
		}	
		
		for(int i = left ; i <= right ; i++){
			arr[i] = sort[i];
		}
	} 

	//분할하는 함수 
	void split(int list[], int left, int right){
		if(left < right){
			int middle = (left + right) / 2;
			split(list, left, middle);
			split(list, middle+1, right);
			merge(list, left, middle, right);
		}
	}


	//메인 함수  
	int main(){
		split(list, 0, 7);
		
		for(int i = 0 ; i < 8 ; i++){
			printf("%d\n", list[i]);
		}
	}
	~~~


	위 코드의 흐름은 일단 main함수 안에서 split함수가 호출됨으로써 시작된다

	split함수는 배열 list를 반절로 분할하는데 재귀적으로 분할한다.

	이 때 배열을 분할한다는 것이 물리적인 배열 분할이 아니다!

	단지 배열의 인덱스를 바꿔줌으로써 배열이 분할된 것과 같은 효과를 주는 것이므로 물리적인 배열 분할을 생각하면 안된다!

	__split함수__ 에서 if(left < right) 라는 조건은 분할된 배열에서 left == right(left와 right가 같아지는 경우는 배열의 길이가 1인 경우이다!) 가 되면 if문을 빠져나오라는 의미이다.

	즉, 분할된 배열의 길이가 1이면 if문 실행이 되지 않는다.

	__merge함수__ 는 3가지 while문이 있다.

	일단 첫번째 while문의 의미를 알아보자!

	![합병정렬8](https://user-images.githubusercontent.com/31889335/57081043-e0dcca00-6d2e-11e9-8513-fbc427bccf12.PNG)

	위와 같은 그림의 두 배열을 합병해서 정렬하는 경우 merge함수를 호출한다고 하자.

	첫번째 while문에서 왼쪽 리스트와 오른쪽 리스트의 첫 번째 원소인 1과 2를 비교한다.

	왼쪽 리스트의 1이 더 작으므로 새로운 배열인 sort의 첫번째 원소에 1을 넣고, leftArrPivot을 인덱스 1로 옮긴다.

	leftArrPivot이 middle보다 작거나 같고, rightArrPivot이 right보다 작거나 같으므로 아직 while문을 만족한다.

	그럼 위와 같은 방법으로 왼쪽 배열의 3과 오른쪽 배열의 10를 비교하여 작은 수를 sort 배열에 넣고, 선택된 배열의 피봇을 1 증가시킨다.

	이 과정을 반복하다 보면

	![합병정렬9](https://user-images.githubusercontent.com/31889335/57081156-27322900-6d2f-11e9-8e87-517bb93b8864.PNG)

	이런 경우가 생길 수 있다. 즉, leftArrPivot이 middle보다 커지는 경우이다!

	무슨 말이냐면 한 쪽 배열의 원소가 다 선택되어 해당 배열의 피봇이 middle을 넘어가는 경우를 말한다.

	이 경우가 되면 첫 번째 while문을 빠져나와 두 번째 or 세 번째 while문이 실행되게 된다.

	위 그림의 경우에는 두 번째 while문은 조건에 맞지 않으므로 실행되지 않고, 세 번째 while문이 실행되는 경우이다.

	세 번째 while문은 남은 오른쪽 배열의 원소인 10, 15를 그대로 sort 배열에 넣는 코드이다.

	이 때, 합병하려는 두 배열은 항상 해당 배열 내에서는 정렬을 이루고 있기 때문에 두 번째 or 세 번째 while문에 의해 차례대로 sort 배열에 들어가도 된다는 것을 이해해야 한다!

	여기까지가 merge함수 코드 흐름이다!

	천천히 살펴보면 이해가 싹~ 될 것이다~!!!

	> 합병 정렬의 정렬 방식은 이해가 100퍼센트 되었는데 막상 코드의 merge 함수 내의 while문 세 개가 이해되지 않아 고생했다...!
	>
	> 처음에는 merge함수가 어떤 역할을 하는지 이해하지 않고 무작정 변수 맞춰 인덱스 옮기기에 바빴는데 이렇게 하니 계속 merge함수를 이해하지 못했다.
	>
	> 이것을 이해하려고 스타벅스에서 약 두 시간 가량 끙끙대다가 남자친구의 전화 설명을 듣고나서야 이해가 되었다! (감사합니당><)
	>
	> 재귀 함수가 파고드는 끝까지 무작정 가서 하나하나 이해하면서 올라오려고 하면 오히려 더 헷갈리고 이해하는데 오랜 시간이 걸린다는 것을 깨달았다!
	>
	> 재귀 함수를 이해하기 위해서는 어떠한 경우에 대해서 그 재귀 함수의 역할을 먼저 이해하면 자연스럽게 전체적인 부분을 이해할 수 있을 것이다!

