---
layout: post
title:  "운영체제1"
date:   2019-04-03 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>
> _1강 - Introduction to Operating Systems_
>
> _🙋 1강에서 설명할 수 있어야 할 것들 🙋_
>
> - 운영체제의 역할
> - 컴퓨터 시스템의 동작 방식
> - 하드웨어에 속하는 것들에 대한 설명
> - 운영체제의 구성 요소

<br>


## ☺ '운영체제'를 '정의' 해보자!
--- 

-  운영체제를 정의하기 위해서는 기본적으로 컴퓨터 시스템은 4가지 구성요소로 이루어져 있다는 것을 알아야한다. 

	컴퓨터시스템(computer system)에는 4가지 구성요소가 있는데,

	- 최상위 요소 : __Users__ (말그대로 컴퓨터를 사용하는 유저)
	- 세번째 요소 : __Applications__ (워드 프로세서, 웹 브라우저, 게임 등등 유저가 사용하는 프로그램들. 유저가 필요할 때 설치하고 사용하지 않을 때는 지우기도 하는 것들)
	- 두번째 요소 : __Operating Systems__ (운영체제)
	- 최하위 요소 : __Hardware__ (컴퓨터 부품들, CPU, 메모리, 입출력장치 등)

		![운영체제1](https://user-images.githubusercontent.com/31889335/55477789-f50ca900-5654-11e9-8504-96a77e025d82.PNG)

		컴퓨터가 부팅되면 하드웨어 위에서 운영체제가 제일 먼저 가동되고 운영체제가 각 어플리케이션의 실행을 관리한다

		위 그림에서 볼 수 있듯이 유저는 운영체제에 직접 접근할 수 없다. 어플리케이션을 통해서 운영체제나 하드웨어에 접근할 수 있다.

		예 ) 유저는 프린트를 하려고 프린터를 실행시키고 싶으면 프린터 실행 프로그램(인쇄 프로그램)을 실행시켜야 하지!

- 운영체제가 뭘까?

	운영체제는 영어로 Operating system 이라고 하고 줄여서 OS라고 한다.

	운영체제는 위 그림에서 알 수 있듯이 컴퓨터 시스템의 4가지 구성요소 중 어플리케이션과 하드웨어를 중개하는 중개인 역할을 하는 시스템이다.

- 사용자들의 시점에서 본 운영체제의 역할

	사용자들의 thinking about OS !

	>운영체제는 어플리케이션을 수행시키고, 사용자들이 컴퓨터 시스템을 사용하기 편리하도록 만드는 시스템이다.

- 컴퓨터시스템의 시점에서 본 운영체제의 역할

	컴퓨터의 thinking about OS !

	> 운영체제는 자원 할당자이다. 그리고, 프로그램들을 컨트롤한다. 즉, 운영체제는 어플리케이션이나 입출력장치의 동작을 컨트롤 한다.
	>
	> _여기서 말하는 __자원__ 이란 뭘까_
	>
	> 자원은 두가지로 분류되는데 __하드웨어 자원__ 과 __소프트웨어 자원__ 으로 나눌 수 있다.
	>
	> 1. 하드웨어 자원 = CPU, 메모리, 입출력 장치
	> 2. 소프트웨어 자원 = 파일들, 소켓 등등
	> 
	> 이 자원들이 관리되어야 하는 이유는 자원은 무한하지 않고 한정되어 있기 때문이다!
	

- 자자! 운영체제가 뭔지를 한줄로 정리해보면?! (출제율↑)

	__어플리케이션과 하드웨어 중간에서 하드웨어 자원(리소스)를 적절하고 효율적으로 관리하는 것!__

- 우리 일상생활에서 어떤 것들을 운영체제라고 할까?

	마이크로소프트의 윈도우, 유닉스, 리눅스, 안드로이드, iOS 등등이 운영체제의 종류이다. 

<br>

## ⚡️ 컴퓨터 시스템 작동 방식
---

- 컴퓨터 시스템의 구성요소 중 하나인 하드웨어는 CPU, 메모리, Disk controller, USB controller, Graphics Adapter 가 하나의 bus로 연결되어 있는 구조이다.

	![운영체네2](https://user-images.githubusercontent.com/31889335/55482565-c47e3c80-565f-11e9-8edf-05174837c389.PNG)

	디스크 컨트롤러는 다시 하드디스크를 연결하고, USB 컨트롤러는 다시 키보드, 마우스, 프린터 등을 연결한다.	

	이때, 컨트롤러는 디바이스(예를 들어, 프린터기)를 구동시키는 프로그램이다.

	<br>

- _CPU_

	![운영체제3](https://user-images.githubusercontent.com/31889335/55970562-bb721880-5cba-11e9-94c1-99e625a3894f.PNG)

	위 그림은 CPU의 모습을 나타낸 그림이다. CPU는 주로 인텔 같은 CPU 회사 이름이 써있는 경우가 많다.

	각 입출력 디바이스 컨트롤러는 local 버퍼(자기 자신의 버퍼 = 조그만 메모리 공간)를 가지고 있다.

	이 버퍼에 임시로 데이터를 잠깐 저장한다.

	마찬가지로 디스크 컨트롤러도 local 버퍼를 갖는데 디바이스와 디바이스 컨트롤러 버퍼간의 데이터를 주고 받을 때 데이터 임시 저장 공간으로 버퍼를 사용하는 것이다.

	또한, CPU도 디스크 컨트롤러와 마찬가지로 버퍼를 데이터를 주고 받을 때 임시 저장 공간으로 사용하지만 CPU 는 메인 메모리와 디바이스 컨트롤러 버퍼간에 데이터를 주고 받는다.

	<br>

- _CPU와 입출력 장치들 간의 관계는 독립적이다_

	CPU와 입출력 장치들은 서로 독립적으로 수행될 수 있다. 만약 CPU가 다른 일을 하고 있을 때 입출력 장치는 CPU가 그 일을 다 마칠때까지 기다려야 할까?

	만약 CPU가 필요하지 않은 작업이라면 CPU가 마칠때까지 기다리지 않고 독자적으로 수행될 수 있다.

	디바이스 컨트롤러는 어떤 디바이스의 수행이 종료되었음을 __interrupt(중단)__ 을 발생시켜서 CPU에게 알려준다. 

	예를 들어, 마우스를 관리하는 디바이스 컨트롤러는 마우스 클릭이 한번 끝날 때마다 interrpt를 발생시킨다.

	<br>

- _interrupt 핸들링_

	만약 디바이스 컨트롤러가 CPU에게 interrupt를 발생시켜서 CPU가 알게되면 CPU는 자신이 하던 일을 멈추고 ISR을 발생시킨다.

	__ISR = Interrupt Service Routine__

	![운영체제4](https://user-images.githubusercontent.com/31889335/55971672-e78e9900-5cbc-11e9-9e65-b8e0e318607a.PNG)

	위 그림에서 민트색으로 표현된 구조를 interrupt vector 테이블이라고 한다.

	이 vector 테이블에는 키보드 interrupt, 마우스 interrupt, 프린트 interrupt, 디스크 interrupt 등 각각의 디바이스에 대한 interrupt 공간이 있다.

	이 테이블에는 각각의 interrupt가 발생하면 어떻게 해야하는지( = interrupt service)가 저장이 되어있다.

	프로그램을 수행하면서 디바이스 컨트롤러에 의해 각각의 interrupt가 발생하면 vector 테이블에서 해당 interrupt 발생 시 정보가 저장되어 있는 칸으로 이동한다. 

	하지만, 이 vector 테이블이 직접 칸에 저장된 서비스대로 수행시키는 것이 아니라 이 서비스는 ISR이 수행시키는 것이다.

	ISR에 의한 서비스 수행이 끝나면 interrupt가 발생되어 중단된 프로그램의 위치로 돌아가 프로그램이 이어서 다시 수행된다.

	_결국, CPU가 뭔가를 수행하고 있어도 interrupt가 발생하면 자신이 하던 일을 멈추고 발생한 interrupt에 해당하는 서비스를 해야한다는 것이다._

	즉, CPU는 사실 엄청 많이 중단되었다가 실행되기를 반복하고 있다. 하지만 CPU가 너무나도 빨라서 중단되지 않는 것으로 보이는 것이다!

<br>

## 🍄 저장 장치들의 구조
---

- _메인 메모리(1차 저장소)_

	CPU가 직접 바로 엑세스할 수 있는 저장장치이다.

	__DRAM( = Dynamic Random Access Memory )__ 이라고도 한다.

	하지만 휘발성이 있어서 전원을 끄면 메인 메모리에 저장한 데이터들이 날아간다. 그래서 HDD나 SSD 같은 2차 저장소를 사용해서 저장해야 한다.

	<br>

- _2차 저장소들_

	2차 저장소들인 __HDD(하드디스크)__, __SSD(Solid State Drive)__, __flash memory__ 등은 휘발성이 없어서 전원을 꺼도 데이터가 사라지지 않으며, 저장공간이 매우 넓다. 단, CPU가 직접 이 저장소들에 접근하지 않는다!

	![운영체제5](https://user-images.githubusercontent.com/31889335/55972895-5c62d280-5cbf-11e9-9bd2-d815a545a651.PNG)

	<br>

- _저장소들의 비교 구조_

	![운영체제6](https://user-images.githubusercontent.com/31889335/55973063-c24f5a00-5cbf-11e9-8c1b-d7e905fb014c.PNG)

	위 그림의 각 항목들은 모두 컴퓨터 시스템에서 사용되는 데이터 저장 공간들이다.

	레지스터 쪽으로 갈수록 속도가 빨라지지만 가격이 비싸고, 저장용량이 적어진다.

	SRAM(CPU 캐시)은 CPU 안에 있는 저장장치로, 인텔 CPU의 i5와 i7의 차이점 중 SRAM 차이도 포함된다.

	<br>
	
- _캐시에 대해서 더 알아보자_

	CPU 캐시가 언제 사용될까?

	하드디스크에 있는 데이터는 메인 메모리로 올라와진다. 또, 메인 메모리로 올라온 데이터는 CPU 캐시로 올라와진다. 최종적으로 CPU 캐시에 있는 데이터들은 레지스터로 올라온다.

	즉, CPU 가까이에 데이터를 놓는 곳이 캐시이다.

	<br>

- _"캐싱한다" 는 무슨 말일까?_

	"캐싱한다" 는 것에 대한 설명을 해보자. 일단 CPU가 어떤 데이터를 얻고자 한다면 얻고자 하는 데이터가 하드디스크에 있는지를 체크한다. 하드디스크에 해당 데이터가 있다면 메인 메모리로 가지고 오고, CPU 캐시에 넣어놓는다.

	이 데이터를 CPU 캐시에 계속 넣어놓으면 CPU가 다음에도 같은 데이터를 원할 때 하드디스크까지 가서 데이터 여부를 확인하지 않고, 바로 CPU 캐시에서 데이터를 찾을 수 있다.

	즉, 제일 먼저 CPU 캐시에 요청하는 데이터가 있는지를 확인하고 있다면 CPU 캐시에 있는 데이터를 바로 사용한다.

	만약 CPU 캐시에 요청하는 데이터가 없어서 하드디스크까지 갔다 와야 하는 상황이라면 그 데이터를 CPU 캐시에 복사해서 가져다 놓는다.

	캐시는 CPU 캐시 개념에서만 쓰이는 개념이 아니다.

	다양한 곳에서 캐시라는 개념이 사용되는데 CPU 캐시 외에도 __OS 버퍼 캐시__, __디스크 캐시__, __웹 캐시__ 등 다양한 곳에서 캐시 개념이 사용된다.

	일반적으로 캐시의 크기는 제한적이다. 

	<br>

## 👙 운영체제의 특징
---

- _멀티프로그래밍_

	운영체제는 여러 개의 프로그램을 동시에 수행시킬 수 있다는 뜻이다.

	이때, 하나의 프로그램이 독자적으로 계속 CPU를 차지하지 않아서 한 프로그램이 끝날 때까지 다른 프로그램들이 실행되지 않는 상황이 발생하지 않는다.

	설명을 조금 더 보충하자면..

	여러개의 프로그램들이 메인 메모리에 같은 시간동안 붙잡혀 있을 수 있다는 것이다.

	그리고, 한 프로그램이 독자적으로 CPU를 차지하지 않는다는 말은 CPU는 실행되는 중에는 하나의 프로그램을 실행시키지만 이 프로그램을 끝까지 실행시키고 있지는 않는다.

	__스케쥴러__ 에 의해 메인 메모리에 올라온 여러 프로그램 중 하나가 선택되고, 선택된 프로그램이 수행되다가 CPU가 실행시키는 프로그램이 다른 프로그램으로 교체되고, 그 동안에는 원래 선택된 프로그램이 기다려야 한다.

	CPU가 여러 프로그램을 돌려가며 실행시키는 특징에 의해 유저들은 여러 프로그램과 상호작용을 할 수 있다.

	<br>

- _타임쉐어링(Timesharing = 시간공유)_

	CPU에게 만약 1초라는 시간이 주어진다면 CPU는 0.1초는 1번 프로그램을 실행시키는데 쓰고, 0.1초는 2번 프로그램을 실행시키는데 쓴다는 뜻이다.

	타임쉐어링은 유닉스라는 운영체제에서 가장 잘 나타내진다.

	<br>

- _듀얼 모드(Dual mode)_

	<br>

## 😎  프로세스 매니지먼트(Management)

- _프로세스(Process)가 뭘까?_

	프로세스는 지금 실행되고 있는 프로그램을 말한다.

	> 잉? 프로그램과 프로세스의 차이가 정확히 뭐지?

	프로세스는 능동적이고 프로그램은 수동적인데 무슨 말이냐하면 프로그램은 아직 실행되지 않은 실행할 수 있는 파일이고 프로세스는 메모리에 올라와 CPU를 할당받고 실행되고 있는 프로그램이다.

	프로세스는 여러가지 자원( = resource)들을 필요로 한다. 예를 들어, CPU, 메모리, 입출력장치들, 파일들 등등!

	<br>

- _프로세스 매니지먼트(관리자)가 하는 일_

	- CPU를 사용하는 프로세스 스케쥴 관리
	- 프로세스 생성 및 삭제
	- 프로세스 동기화 
	- 프로세스들 간의 커뮤니티
	- 데드락 핸들링

	<br>

## 💽 메모리 매니지먼트
---

- _메모리 매니지먼트가 하는 일_

	- 메모리의 어떤 부분을 누구에게 줄 것인가 결정
	- 어떤 프로세스와 어떤 데이터가 메모리로 올려질 것인가를 결정

	메모리가 한정적이기 때문에 위의 항목들을 메모리 매니지먼트가 잘 결정해야 한다.

	<br>

- _가상 메모리 시스템_

	<br>

## 💾 저장 매니지먼트
---

- _운영체제는 정보 저장에 대한 논리적이고 통일된 저장소를 제공한다._

	- File 저장소

		데이터를 저장할 때 파일을 주로 많이 사용한다. 파일은 소프트웨어적인 저장공간이다.

	- 파일 시스템

	<br>

- _파일 시스템이 하는 일_

	- 파일과 디렉토리를 생성 및 삭제한다.
	- 파일과 디렉토리를 조작한다.
	- 파일을 실제 저장소와 어떻게 매핑 시킬 것인지를 관리한다.

	<br>

- _대용량 저장소 매니지먼트_

	보통 데이터를 저장할 때는 저장 공간이 대용량인 디스크를 많이 사용한다. 

	하지만 컴퓨터 속도는 디스크 시스템과 디스크 알고리즈에 의해 많이 좌우된다.

	<br>

## 📺 I/O 서브 시스템
---

- _I/O 서브 시스템들은 다음과 같은 요소들로 구성되어 있다_

	- 디스크 드라이버 인터페이스
	- 

	<br>

## 🌀 특별한 목적을 위한 시스템들
---

- _리얼 타임 시스템_

	리얼 타임 운영체제를 말하는 것이다. 

	real time = __실시간__

	리얼 타임 시스템은 데드라인이 중요한 시스템이다. 즉, 요청에 의한 응답시간이 실시간으로 수행되어야 한다.

	미사일 제어 시스템이나 운전 시스템, 의료 기계 시스템에 사용되는 운영체제가 리얼 타임 시스템 운영체제에 속한다.

	<br>

- _멀티미디어 시스템_

	멀티미디어에 최적화 해놓은 시스템으로 MP3 플레이어, DVD 플레이어 등을 잘 관리하는 시스템이다.

	약간의 리얼타임 시스템이 요구된다.

	<br>

## 💭 가상 머신(Virtual Machine)
---

- _가상머신이 뭐지?_

	여러개의 다른 실행 환경을 제공하는 추상적인 단일 컴퓨터이다.

	무슨 말이냐면 하나의 노트북에서 종류가 다른 여러 운영체제를 수행하려 할 때 가상머신을 사용해야 한다는 뜻이다!

	가상 머신을 사용하지 않으면 실제로 여러개의 다른 OS를 한 컴퓨터에서 수행시킬 수 없다.

	가상머신은 각각의 분리된 실행 환경이 하나의 컴퓨터에 환각적으로 생성되는 방식이다.

	가상 머신을 줄여서 VM 이라고도 부른다.

	<br>

- _가상 머신의 특징_

	







	








