---
layout: post
title:  "알고리즘 스터디 <효율적인 알고리즘>"
date:   2019-03-28 18:34:10 +0700
categories: [algorithm]
---


> <알기 쉬운 알고리즘, 양성봉, 생능출판> 책으로 공부한 알고리즘

<br>


## ⌚️ 가장 오래된 알고리즘
--- 

ㅏㅏ
-  가장 오래된 알고리즘은 기원전 300년경에 만들어졌는데 __유클리드의 최대 공약수를 찾는 알고리즘__ 이다

	유클리드가 생각해낸 두 수의 최대공약수를 구하는 방법은

	> 두 수의 최대공약수 = (두 수 중 큰수 - 작은수) 와 두 수 중 작은 수와의 최대공약수

	이다. 직접 해보면 진짜로 같다!

	이 방법으로 한번 24와 14의 최대공약수를 구해보면,

	> __24와 14의 최대 공약수__ = (24 - 14)와 14의 최대공약수 = 10과 14의 최대공약수 
	> 
	> = (14 - 10)와 10의 최대공약수 = __4와 10의 최대공약수__
	>
	> = (10 - 4)와 4의 최대공약수 = __6과 4의 최대공약수__
	>
	> = (6 - 4)와 4의 최대공약수 = __2와 4의 최대공약수__
	>
	> = (4 - 2)와 2의 최대공약수 = __2와 2의 최대공약수__
	>
	> = (2 - 2)와 2의 최대공약수 = __0과 2의 최대공약수__ = __2__ (0과 어떤 수의 최대공약수는 어떤 수 이다)					   

	위 뺄셈 과정은 나머지 연산으로 똑같이 표현할 수 있는데 나머지 연산으로 계산하면 뺄셈으로 계산하는 것보다 훨씬 빠르게 해를 찾을 수 있다. 

	왜냐하면 뺄셈 과정 중 몇 개가 생략되기 때문이다.

	위 뺄셈 과정은 아래와 같은 나머지 연산으로 대체될 수 있다.

	> __24와 14의 최대 공약수__ = 두 수 중 작은 수와 (큰 수에서 작은 수를 나눈 나머지)

	이 방법으로 다시 구해보면,

	> __24와 14의 최대 공약수__ = __14와 10의 최대공약수__
	>
	> = __10과 4의 최대 공약수__
	>
	> = __4와 2의 최대 공약수__
	>
	> = __2와 0의 최대 공약수__ = __2__ 

	이렇게 더 단축된 과정으로 최대 공약수가 구해진다

	위 과정을 자세히 살펴보면 같은 과정을 반복하는 모습을 볼 수 있다. 이렇게 같은 과정을 반복하는 코드를 짜야 한다면 _재귀함수_ 를 활용하는 것이 좋다.

	~~~c
		int gcd(int m, int n){
			if(n == 0){
				return m;
			}else{
				return gcd(n, m%n);
			}
		}	
		//매개변수를 넣을 때 조건은 m > n 이다
		//gcd어원 = greatest common divisor = 최대 공약수
	~~~

	위는 재귀함수를 이용하여 최대공약수를 구하는 코드이다 

	__재귀함수를 호출할 때는 return 뒤에 호출한다__ 


	<br>

## 🕣🕘 알고리즘은 효율성을 따져야 한다!
--- 


- 왜 효율적인 알고리즘을 구현하려고 노력할까?

	동일한 문제를 해결해주는 여러 개의 알고리즘이 있을 때 당연히 시간상 빨리 문제를 해결해주는 알고리즘이 더 효율적이고 좋은 알고리즘이라고 생각이 든다.

	실제로 2개의 서로 다른 정렬 알고리즘을 사용해서 10억개의 숫자를 실제 PC에서 정렬해보자고 하자. 둘 중 빠른 정렬 알고리즘은 10억개의 숫자를 정렬하는데 5분이 걸리는 반면, 느린 정렬 알고리즘은 10억개를 정렬하는데 300년이 걸린다. ㄷㄷ..

	입력 크기가 작으면 빠른 알고리즘을 사용하든 느린 알고리즘을 사용하든 비슷한 수행 시간이 걸리지만 입력 크기가 커지면 커질수록 수행시간의 차이는 점점 커지게 된다.

	따라서 우리는 효율적인 알고리즘을 구현하여 좀 더 빠른 시간에 답을 구하기 위해 노력해야하는 것이다.  

	<br>

- 	알고리즘이 얼마나 효율적인지 볼 수 있는 표현식이 있다!

	알고리즘의 효율성은 두 가지 면으로 따져볼 수 있는데 __수행 시간__ 과 __사용되는 메모리 공간의 크기__ 로 따질 수 있다. 

	이 두 가지는 살짝쿵 전문 용어로 __시간복잡도__ 와 __공간복잡도__ 라고 표현한다

	우선 어떤 알고리즘의 수행시간이 얼마나 걸리는지를 어떻게 알아내는지 생각해보자 ( 즉, 어떤 알고리즘의 시간 복잡도가 얼마인지를 생각해보자는 것과 같다 )

	가장 쉬운 방법은 해당 알고리즘을 컴퓨터에서 실행시켜 수행된 시간을 측정해 보는 것이다. 
	
	이 방법은 단점이 있는데 실행시켜본 컴퓨터의 사양에 따라 수행된 시간이 달라질 수 있다는 점이다

	그래서 좀 더 객관적인 시간복잡도를 알아보기 위해서 우리는 __해당 알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수__ 로 시간복잡도를 표현한다.

	예를 들어, 10개의 숫자 중 가장 큰 숫자를 찾는 알고리즘이 있다고 하자. 이 알고리즘의 기본적인 연산은 숫자를 비교하는 비교 연산이고, 비교를 총 9번 하게 된다. 또, 입력 크기는 10이다. 


	<br>

##  📐 보간 탐색 알고리즘
---

-  탐색대상의 인덱스를 찾는 방식이 독특한 알고리즘! 

	단, 배열에 수들이 정렬되어 있어야 한다

	_배열의 맨 마지막 숫자와 맨 처음 숫자의 차_ 와 _찾고자 하는 숫자와 맨 처음 숫자의 차_ 의 비율이 _맨 마지막 인덱스와 처음 인텍스의 차_ 와 _찾고자 하는 숫자의 인덱스와 처음 인덱스의 차_ 의 비율과 같다고 생각한다

	![보간탐색](https://user-images.githubusercontent.com/31889335/54733145-56576580-4bdb-11e9-9c4a-eefb53dbc691.PNG)

	위 그림의 정렬된 배열에서 찾고자 하는 수가 24라고 하면

	30 - 10 : 24 - 10 인 20 : 14 와

	20(원소 30의 인덱스) - 0(원소 10의 인덱스) : x(원소 24의 인덱스) - 0(원소 10의 인덱스)인 20 : 14와 같다고 보는 것이다

	즉, 맨끝 원소 - 처음 원소 : 찾고자하는 원소 - 처음 원소 = 맨 끝 인덱스 - 처음 인덱스 : 찾고자하는 인덱스 - 처음 인덱스

	이므로 비례식을 풀면

	![보간탐색2](https://user-images.githubusercontent.com/31889335/54733295-47bd7e00-4bdc-11e9-9828-aa8b0122fbef.PNG)

	이다. 여기서 s는 찾고자 하는 원소의 인덱스이고 x는 찾고자 하는 수이다!
	즉, s가 대충 이쪽에 있을 것이라고 예상하고 s를 바로 구해서 예상한 s의 arr[s]가 target인지 아닌지를 바로 판별하는 식이다

	그럼 C언어 코드로 보간탐색 알고리즘을 짜보자!

	~~~c
		int Search(int arr[], int len, int target){
			int low = 0;
			int high = len-1;
			int s;

			while(arr[low] > target || arr[high] < target){
				s = (target - arr[low]) / (arr[high] - arr[low]) * (high - low) + low;

				if(arr[s] == target){
					return s;
				}else if(target < arr[s]){
					low = s + 1;
				}else{
					high = s - 1;
				}
			}
			return -1;
		}
	~~~

	첫번째 인자에는 정렬된 배열을 넣고, 두번째 인자에는 배열의 크기를 넣고, 세번째 인자에는 찾고자 하는 숫자값을 넣는다

	공식에 의해서 구해진 s값에 따라 arr[s] != target 이면 arr[s]와 target의 크기를 비교하여 low값과 high값을 다시 잡는다

	그리고 나서 다시 정해진 범위인 low ~ high 사이에서 s값을 또 구해서 이 과정을 반복한다

## 👀 위의 세 탐색 알고리즘의 속도 비교
---
- 속도는 보간 탐색 > 이진 탐색 > 순차 탐색 순으로 빠르다 !
	
