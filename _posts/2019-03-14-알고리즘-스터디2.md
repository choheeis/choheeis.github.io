---
layout: post
title:  "알고리즘 스터디 <효율적인 알고리즘>"
date:   2019-03-28 18:34:10 +0700
categories: [algorithm]
---


> <알기 쉬운 알고리즘, 양성봉, 생능출판> 책으로 공부한 알고리즘

<br>


## ⌚️ 가장 오래된 알고리즘
--- 

-  가장 오래된 알고리즘은 기원전 300년경에 만들어졌는데 __유클리드의 최대 공약수를 찾는 알고리즘__ 이다

	유클리드가 생각해낸 두 수의 최대공약수를 구하는 방법은

	> 두 수의 최대공약수 = (두 수 중 큰수 - 작은수) 와 두 수 중 작은 수와의 최대공약수

	이다. 직접 해보면 진짜로 같다!

	이 방법으로 한번 24와 14의 최대공약수를 구해보면,

	> __24와 14의 최대 공약수__ = (24 - 14)와 14의 최대공약수 = 10과 14의 최대공약수 
	> 
	> = (14 - 10)와 10의 최대공약수 = __4와 10의 최대공약수__
	>
	> = (10 - 4)와 4의 최대공약수 = __6과 4의 최대공약수__
	>
	> = (6 - 4)와 4의 최대공약수 = __2와 4의 최대공약수__
	>
	> = (4 - 2)와 2의 최대공약수 = __2와 2의 최대공약수__
	>
	> = (2 - 2)와 2의 최대공약수 = __0과 2의 최대공약수__ = __2__ (0과 어떤 수의 최대공약수는 어떤 수 이다)					   

	위 뺄셈 과정은 나머지 연산으로 똑같이 표현할 수 있는데 나머지 연산으로 계산하면 뺄셈으로 계산하는 것보다 훨씬 빠르게 해를 찾을 수 있다. 

	왜냐하면 뺄셈 과정 중 몇 개가 생략되기 때문이다.

	위 뺄셈 과정은 아래와 같은 나머지 연산으로 대체될 수 있다.

	> __24와 14의 최대 공약수__ = 두 수 중 작은 수와 (큰 수에서 작은 수를 나눈 나머지)

	이 방법으로 다시 구해보면,

	> __24와 14의 최대 공약수__ = __14와 10의 최대공약수__
	>
	> = __10과 4의 최대 공약수__
	>
	> = __4와 2의 최대 공약수__
	>
	> = __2와 0의 최대 공약수__ = __2__ 

	이렇게 더 단축된 과정으로 최대 공약수가 구해진다

	위 과정을 자세히 살펴보면 같은 과정을 반복하는 모습을 볼 수 있다. 이렇게 같은 과정을 반복하는 코드를 짜야 한다면 _재귀함수_ 를 활용하는 것이 좋다.

	~~~c
		int gcd(int m, int n){
			if(n == 0){
				return m;
			}else{
				return gcd(n, m%n);
			}
		}	
		//매개변수를 넣을 때 조건은 m > n 이다
		//gcd어원 = greatest common divisor = 최대 공약수
	~~~

	위는 재귀함수를 이용하여 최대공약수를 구하는 코드이다 

	__재귀함수를 호출할 때는 return 뒤에 호출한다__ 


	<br>

## 🕣🕘 알고리즘은 효율성을 따져야 한다!
--- 


- 왜 효율적인 알고리즘을 구현하려고 노력할까?

	동일한 문제를 해결해주는 여러 개의 알고리즘이 있을 때 당연히 시간상 빨리 문제를 해결해주는 알고리즘이 더 효율적이고 좋은 알고리즘이라고 생각이 든다.

	실제로 2개의 서로 다른 정렬 알고리즘을 사용해서 10억개의 숫자를 실제 PC에서 정렬해보자고 하자. 둘 중 빠른 정렬 알고리즘은 10억개의 숫자를 정렬하는데 5분이 걸리는 반면, 느린 정렬 알고리즘은 10억개를 정렬하는데 300년이 걸린다. ㄷㄷ..

	입력 크기가 작으면 빠른 알고리즘을 사용하든 느린 알고리즘을 사용하든 비슷한 수행 시간이 걸리지만 입력 크기가 커지면 커질수록 수행시간의 차이는 점점 커지게 된다.

	따라서 우리는 효율적인 알고리즘을 구현하여 좀 더 빠른 시간에 답을 구하기 위해 노력해야하는 것이다.  

	<br>

- 	알고리즘이 얼마나 효율적인지 볼 수 있는 표현식이 있다!

	알고리즘의 효율성은 두 가지 면으로 따져볼 수 있는데 __수행 시간__ 과 __사용되는 메모리 공간의 크기__ 로 따질 수 있다. 

	이 두 가지는 살짝쿵 전문 용어로 __시간복잡도__ 와 __공간복잡도__ 라고 표현한다

	우선 어떤 알고리즘의 수행시간이 얼마나 걸리는지를 어떻게 알아내는지 생각해보자 ( 즉, 어떤 알고리즘의 시간 복잡도가 얼마인지를 생각해보자는 것과 같다 )

	가장 쉬운 방법은 해당 알고리즘을 컴퓨터에서 실행시켜 수행된 시간을 측정해 보는 것이다. 
	
	이 방법은 단점이 있는데 실행시켜본 컴퓨터의 사양에 따라 수행된 시간이 달라질 수 있다는 점이다

	그래서 좀 더 객관적인 시간복잡도를 알아보기 위해서 우리는 __해당 알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수__ 로 시간복잡도를 표현한다.

	예를 들어, 10개의 숫자 중 가장 큰 숫자를 찾는 알고리즘이 있다고 하자. 이 알고리즘의 기본적인 연산은 숫자를 비교하는 비교 연산이고, 비교를 총 9번 하게 된다. 또, 입력 크기는 10이다. 


	<br>

##  