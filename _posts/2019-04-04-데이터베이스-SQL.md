---
layout: post
title:  "데이터베이스3<SQL>"
date:   2019-04-04 18:34:10 +0700
categories: [database]
---


> 서울과학기술대학교 3학년 교과과정인 '데이터베이스' 시험공부를 위한 포스팅!
>
> Chapet 3 - Introduction to SQL
>
> _🙋 이 포스팅을 읽고 설명할 수 있어야 할 것들 🙋_
>
> - SQL 쿼리 언어의 개요에 대해서
> - 데이터 타입에 대해서
> - 기본적인 쿼리문의 구조에 대해서
> - 기본적인 데이터 베이스 연산 기능들에 대해서
> - 함수 세팅하기에 대해서
> - Null 값에 대해서
> - 중복 쿼리문에 대해서
> - 데이터베이스 수정하기에 대해서

<br>

## 💭 SQL 쿼리 언어의 개요
---
- SQL이 뭘까

	SQL은 Structured Query Language의 약자로 ...흠 다시!ㅋㅋㅋㅋ

	<br>

## 🙉 SQL의 도메인 타입
---


> 도메인..? 내가 아는 도메인은 naver.com 할때의 도메인인뎅,, 흠 다시!

기본적인 도메인 타입들만 알아보자!

__char(n)__ : 이 타입을 데이터 타입으로 설정하면 길이가 n개로 고정된 데이터가 저장된다는 뜻이다.

__varchar(n)__ : variable character의 약자로(variable = 변하기 쉬운, 가변적인) 최대 n개의 길이를 가진 문자열 데이터를 저장한다는 뜻이다. 즉, n개 이하의 길이를 가진 데이터들을 저장할 수 있다는 것이다. (요즘에는 varchar2타입을 쓴다.)

__int__ : 이 타입을 데이터 타입으로 설정하면 4바이트 정수를 저장하겠다는 뜻이다. 

__smallint__ : 이 타입을 데이터 타입으로 설정하면 작은 정수를 저장하겠다는 뜻이다...? 작은정수가 뭐여,,,

__numeric(p,d)__ : 이 타입을 데이터 타입으로 설정하면 고정 소수점으로 표현된 실수를 저장하겠다는 뜻이다. p는 정수부분의 수이고, d는 소수점 뒷 부분 수이다. (예 - 3.41에서 p는 3, d는 0.41이 된다.)

__real, double precision__ : 이 타입을 데이터 타입으로 설정하면 4바이트 부동 소수점으로 표현된 실수와 8바이트 부동 소수점으로 표현된 실수(double)를 저장하겠다는 뜻이다.

__float(n)__ : 이 타입을 데이터 타입으로 설정하면 4바이트 부동 소수점으로 표현된 실수를 저장하겠다는 것이고, 적어도 정수 n ....?

<br>

## 🔨 기본적인 쿼리문의 구조
---

- __새로운 관계형 테이블을 생성하기 위한 쿼리문__

	__create table 테이블이름 (attribute이름 데이터타입 , ... )__ 이라는 SQL을 작성하여 괄호안의 attribute들을 갖는 테이블을 생성할 수 있다.

	예를 들어, 

	![데이터베이스1](https://user-images.githubusercontent.com/31889335/55642003-3c886600-580a-11e9-9449-1369f83551ca.PNG)
	
	위 쿼리문을 작성하면 instructor라는 이름의 관계형 테이블이 생성된다.

	<br>


- __테이블에 실제적인 데이터를 삽입하기 위한 쿼리문__

	__insert into 테이블이름 values (attribute순서에 맞는 각각의 데이터들을 콤마로 이곳에 작성한다.);__ 이라는 SQL을 작성하면 된다. 이때 새미콜론 찍는것 잊지말자!

	예를 들면,

	![데이터베이스2](https://user-images.githubusercontent.com/31889335/55642533-b53bf200-580b-11e9-8669-913377348134.PNG)

	위 쿼리문을 작성하면 ID, name, dept_name, salary 속성의 순서에 맞게 테이블의 첫 가로줄이 완성된다.

	<br>


- __관계형 테이블을 생성할 때 제약조건을 주는 쿼리문__

	3가지 제약조건이 있다.

	1. not null
	2. primary key(attribute 이름)
	3. foreign key(attribute 이름) references 테이블 이름	

	![데이터베이스3](https://user-images.githubusercontent.com/31889335/55643407-fe8d4100-580d-11e9-893e-bbfaad7adfed.PNG)

	위 쿼리문처럼 테이블 생성 쿼리문의 괄호 안에 primary key와 foreign key를 지정해준다.

	primary key는 항상 not null인 특징을 자동적으로 가지게 된다.

	![데이터베이스4](https://user-images.githubusercontent.com/31889335/55643499-44e2a000-580e-11e9-9994-f59e0fa7e387.PNG)

	primary key를 지정해주는 쿼리문은 위와 같이 primary key의 데이터 타입 뒤에 바로 써줘도 된다.

	<br>

- __쿼리문의 기본 구조__

	전형적인 쿼리문의 구조는 다음과 같다!

	__select__ 선택할 attribute들을 콤마로 구분하여 나열 __from__ 관계형 테이블들을 콤마로 구분하여 나열 __where__ 조건문

	의 구조인 select - from - where 구조이다.

	위의 쿼리문의 결과는 또 다른 새로운 관계형 테이블이다.

	<br>

- __select에 대해서__

	만약, instructor 테이블의 name이라는 attribute의 모든 데이터 값들을 가져오고 싶다면,

	__select__ name __from__ instructor

	이라고 쿼리문을 작성하면 된다. 

	SQL은 쿼리문의 __결과__ 로 나온 테이블에서만 중복을 허용한다.

	따라서, __select all__ dept_name __from__ instructor 이라는 쿼리문은 중복된 것을 중복된 채로 다 선택하라는 뜻이다.

	만약 __결과__ 로 나온 테이블에서 중복을 허용하지 않고 싶다면 __select distinct__ dept_name __from__ instructor

	이라는 쿼리문을 작성하면 된다.  

	__select * from__ instructor 이라는 쿼리문은 * = 모든 attribute 라는 의미여서 instructor 테이블의 모든 attribute 값을 출력하라는 뜻이다.

	__select__ 문 뒤의 attribute 들에 사칙연산자를 붙일 수도 있다.

	![데이터베이스5](https://user-images.githubusercontent.com/31889335/55644667-917baa80-5811-11e9-889d-7bcdb21594a3.PNG)
	
	위 쿼리문은 나누기 연산인 / 가 salary 라는 attribute 에 붙여서 쓰였는데 instructor 테이블의 salary 라는 attribute의 데이터 값들을 12로 나눈 값들로 바꿔서 출력하라는 뜻이다. (즉, 연봉/12 이므로 월급을 출력해다라는 것이다.)

	<br>

- __from에 대해서__

	__from__ 뒤에 여러개의 테이블이 콤마로 구분되어 작성되면 각 테이블을들 _데카르트의 곱셈_ 을 하여 나온 새로운 테이블에서 선택하라는 뜻이다.

	이때, 데카르트의 곱셈을 할 때 고려해야할 조건을 __where__ 뒤에 써줘야 한다. 써주지 않으면 각 테이블의 전체가 데카르트의 곱셈 연산이 되어 매우 비효율적이게 된다.

	<br>

- __where에 대해서__

	만약, instructor 테이블에서 dept_name 이라는 attribute의 데이터 값이 Comp.Sic 이고 salary 라는 attribute 의 데이터 값이 80000 이 넘는 테이블 row의 name이라는 attribute를 선택하고 싶다면

	__select__ name __from__ instructor __where__ dept_name = 'Comp.Sic' __and__ salary > 80000

	이라는 쿼리문을 작성하면 된다.

	where뒤의 조건식에는 __and__, __or__, __not__ 의 비교식을 쓸 수 있다.

	<br>
	

## ✖️ ➕기본적인 데이터 베이스 연산 기능들에 대해서	 
---

- 서로 다른 테이블에 이름이 같은 attribute가 있을 경우 구별하는 방법

	![데이터베이스6](https://user-images.githubusercontent.com/31889335/55646407-15379600-5816-11e9-9d87-1f0fe71aa3c1.PNG)


	![데이터베이스7](https://user-images.githubusercontent.com/31889335/55646531-5af45e80-5816-11e9-8bee-c5df58b02c21.PNG)

	위 두 개의 테이블을 참고하여

	course_id(강좌번호)를 갖는 교수들의 이름과 그들이 가르치는 course_ID을 선택하는 쿼리문을 작성해야 한다고 해보자!

	__select__ name, course_id __from__ instructor, teaches __where__ instructor.ID = teaches.ID

	라는 쿼리문을 작성하면 된다는 것이 이해가 될 것이다.

	위와 같은 경우에서 볼 수 있듯이, 서로 다른 테이블에 이름이 같은 attribute가 있으면 각각의 서로 다른 테이블에 있는 attribute임을 명시하기 위해 __테이블이름.attribute이름__ 이라고 나타내야 한다.

	위 두 개의 테이블과 아래 테이블을 참고하여

	Comp.Sci 전공에서 제공하는 각각의 강좌들의 정보를 찾는 쿼리문을 작성해보자. (강좌들의 course_ID와 semester, year, title을 선택하자) 

	![데이터베이스8](https://user-images.githubusercontent.com/31889335/55647078-ba06a300-5817-11e9-9c8b-1fef31bb561b.PNG)


	__select__ section.course_id, semester, year, title __from__ section, course __where__ section.course_id = course.course_id __and__ dept_name = 'Comp.Sic'

	라고 작성하면 된다. 


	<br>

- natural join에 대해서

	Natural join 이란 두 테이블을 합치는데 동일한이름과 동일한 데이터값들을 가진 column(세로줄)이 있으면 join된 테이블의 결과에 한번만 표기하는 join 방법이다.

	예를 들어, 

	__select__ * __from__ instructor __natural join__ teaches;

	라는 SQL문을 출력하면 

	![데이터베이스9](https://user-images.githubusercontent.com/31889335/55647707-4c5b7680-5819-11e9-9059-582dd7bee598.PNG)

	가 결과로 나오는데 이 결과는 instructor 테이블과 teaches 테이블을 합치는 대신 두 테이블 모두 동일한 값을 가지는 column인 ID attribute column을 한번만 쓴 테이블이다.

	_! natural join을 할 때 주의할 점 !_

	동일한 이름의 attribute이지만 관련이 없는 attribute를 조심하자.	

	예를 들어, 

	교수들의 이름을 선택하는 쿼리문을 작성하는데, 그 교수들이 가르치는 강좌의 제목을 같이 출력하는 쿼리문을 작성하여라.

	
	

