---
layout: post
title:  "데이터베이스3 <SQL>"
date:   2019-04-04 18:34:10 +0700
categories: [database]
---


> 서울과학기술대학교 3학년 교과과정인 '데이터베이스' 시험공부를 위한 포스팅!
>
> Chapet 3 - Introduction to SQL
>
> _🙋 이 포스팅을 읽고 설명할 수 있어야 할 것들 🙋_
>
> - SQL 쿼리 언어의 개요에 대해서
> - 데이터 타입에 대해서
> - 기본적인 쿼리문의 구조에 대해서
> - 기본적인 데이터 베이스 연산 기능들에 대해서
> - 함수 세팅하기에 대해서
> - Null 값에 대해서
> - 중복 쿼리문에 대해서
> - 데이터베이스 수정하기에 대해서

<br>

## 💭 SQL 쿼리 언어의 개요
---
- SQL이 뭘까

	SQL은 Structured Query Language의 약자로 ...흠 다시!ㅋㅋㅋㅋ

	<br>

## 🙉 SQL의 도메인 타입
---


> __도메인__ : 앞 포스팅에서 도메인은 가능한 attribute 값들의 집합이라고 했당!

도메인 타입들을 알아보자! 즉, 도메인의 유형을 알아보자는 것!

__char(n)__ : 이 타입을 데이터 타입으로 설정하면 길이가 n개로 고정된 데이터가 저장된다는 뜻이다.

__varchar(n)__ : variable character의 약자로(variable = 변하기 쉬운, 가변적인) 최대 n개의 길이를 가진 문자열 데이터를 저장한다는 뜻이다. 즉, n개 이하의 길이를 가진 데이터들을 저장할 수 있다는 것이다. (요즘에는 varchar2타입을 쓴다.)

__int__ : 이 타입을 데이터 타입으로 설정하면 4바이트 정수를 저장하겠다는 뜻이다. 

__smallint__ : 이 타입을 데이터 타입으로 설정하면 작은 정수를 저장하겠다는 뜻이다...? 작은정수가 뭐여,,,

__numeric(p,d)__ : 이 타입을 데이터 타입으로 설정하면 고정 소수점으로 표현된 실수를 저장하겠다는 뜻이다. p는 정수부분의 수이고, d는 소수점 뒷 부분 수이다. (예 - 3.41에서 p는 3, d는 0.41이 된다.)

__real, double precision__ : 이 타입을 데이터 타입으로 설정하면 4바이트 부동 소수점으로 표현된 실수와 8바이트 부동 소수점으로 표현된 실수(double)를 저장하겠다는 뜻이다.

__float(n)__ : 이 타입을 데이터 타입으로 설정하면 4바이트 부동 소수점으로 표현된 실수를 저장하겠다는 것이고, 적어도 정수 n ....?

<br>

## 🔨 기본적인 쿼리문의 구조

---

- _새로운 관계형 테이블을 생성하기 위한 쿼리문_

	__create table 테이블이름 (attribute이름 데이터타입 , ... )__ 이라는 SQL을 작성하여 괄호안의 attribute들을 갖는 테이블을 생성할 수 있다.

	예를 들어, 

	![데이터베이스1](https://user-images.githubusercontent.com/31889335/55642003-3c886600-580a-11e9-9449-1369f83551ca.PNG)
	
	위 쿼리문을 작성하면 instructor라는 이름의 관계형 테이블이 생성된다.


	<br>


- __테이블에 실제적인 데이터를 삽입하기 위한 쿼리문__

	__insert into 테이블이름 values (attribute순서에 맞는 각각의 데이터들을 콤마로 이곳에 작성한다.);__ 이라는 SQL을 작성하면 된다. 이때 새미콜론 찍는것 잊지말자!

	예를 들면,

	![데이터베이스2](https://user-images.githubusercontent.com/31889335/55642533-b53bf200-580b-11e9-8669-913377348134.PNG)

	위 쿼리문을 작성하면 ID, name, dept_name, salary 속성의 순서에 맞게 테이블의 첫 가로줄이 완성된다.

	<br>


- __관계형 테이블을 생성할 때 제약조건을 주는 쿼리문__

	3가지 제약조건이 있다.

	1. not null
	2. primary key(attribute 이름)
	3. foreign key(attribute 이름) references 테이블 이름	

	![데이터베이스3](https://user-images.githubusercontent.com/31889335/55643407-fe8d4100-580d-11e9-893e-bbfaad7adfed.PNG)

	위 쿼리문처럼 테이블 생성 쿼리문의 괄호 안에 primary key와 foreign key를 지정해준다.

	primary key는 항상 not null인 특징을 자동적으로 가지게 된다.

	![데이터베이스4](https://user-images.githubusercontent.com/31889335/55643499-44e2a000-580e-11e9-9994-f59e0fa7e387.PNG)

	primary key를 지정해주는 쿼리문은 위와 같이 primary key의 데이터 타입 뒤에 바로 써줘도 된다.

	<br>

- __쿼리문의 기본 구조__

	전형적인 쿼리문의 구조는 다음과 같다!

	__select__ 선택할 attribute들을 콤마로 구분하여 나열 __from__ 관계형 테이블들을 콤마로 구분하여 나열 __where__ 조건문

	의 구조인 select - from - where 구조이다.

	위의 쿼리문의 결과는 또 다른 새로운 관계형 테이블이다.

	<br>

- __select에 대해서__

	만약, instructor 테이블의 name이라는 attribute의 모든 데이터 값들을 가져오고 싶다면,

	__select__ name __from__ instructor

	이라고 쿼리문을 작성하면 된다. 

	테이블에서는 한개의 attribute의 데이터 값들이 똑같은 값을 갖는 경우가 있다. (예 - name이라는 attribute 값에 동명이인이 있을 경우) 

	이런 경우에 선택된 새로운 테이블에 중복된 데이터들을 모두 중복된 만큼 표시하지 않고 한번만 표시하도록 하는 select 문은 __select distinct__ 이다

	![데이터베이스19](https://user-images.githubusercontent.com/31889335/55685277-222bc500-598f-11e9-9386-e0bff9dff63e.PNG)

	그럼 위와 같은 테이블에서 __select distinct__ dept_name __from__ instructor 쿼리문을 실행시키면 아래와 같은 테이블이 선택된다.

	따라서, __select all__ dept_name __from__ instructor 이라는 쿼리문은 dept_name이라는 attribute의 데이터값들 중 중복된 값이 있어도 중복된 채로 다 선택하라는 뜻이다. select 뒤에 아무것도 안써도 all을 쓴 것과 같은 의미이다.

	__select * from__ instructor 이라는 쿼리문은 (* = 모든 attribute) 라는 의미여서 instructor 테이블의 모든 attribute 값을 출력하라는 뜻이다.

	__select__ 문 뒤의 attribute 들에는 사칙연산자를 붙일 수도 있다!!

	![데이터베이스5](https://user-images.githubusercontent.com/31889335/55644667-917baa80-5811-11e9-889d-7bcdb21594a3.PNG)
	
	위 쿼리문은 나누기 연산인 / 가 salary 라는 attribute 에 붙여서 쓰였는데 instructor 테이블의 salary 라는 attribute의 데이터 값들을 12로 나눈 값들로 바꿔서 출력하라는 뜻이다. (즉, 연봉/12 이므로 월급을 출력해다라는 것이다.)

	<br>

- __from에 대해서__

	__from__ 뒤에 여러개의 테이블이 콤마로 구분되어 작성되면 각 테이블들은 _데카르트의 곱셈_ 을 하여 나온 새로운 테이블이고 이 새로운 테이블에서 attribute 값들을 선택하라는 뜻이다.

	이때, 데카르트의 곱셈을 할 때 고려해야할 조건을 __where__ 뒤에 써줘야 한다. 써주지 않으면 각 테이블의 전체가 데카르트의 곱셈 연산이 되어 매우 비효율적이게 된다.

	<br>

- __where에 대해서__

	만약, instructor 테이블에서 dept_name 이라는 attribute의 데이터 값이 Comp.Sic 이고 salary 라는 attribute 의 데이터 값이 80000 이 넘는 테이블 row의 name이라는 attribute를 선택하고 싶다면

	__select__ name __from__ instructor __where__ dept_name = 'Comp.Sic' __and__ salary > 80000

	이라는 쿼리문을 작성하면 된다.

	실제 인스턴스들을 쿼리문에 조건문으로 적을 때에는 문자열을 작은따옴표로 묶어서 작성한다.

	where뒤의 조건식에는 __and__, __or__, __not__ 의 비교식을 쓸 수 있다.

	<br>
	

## ✖️ ➕기본적인 데이터 베이스 연산 기능들에 대해서	 
---

- 서로 다른 테이블에 이름이 같은 attribute가 있을 경우 구별하는 방법

	![데이터베이스6](https://user-images.githubusercontent.com/31889335/55646407-15379600-5816-11e9-9d87-1f0fe71aa3c1.PNG)


	![데이터베이스7](https://user-images.githubusercontent.com/31889335/55646531-5af45e80-5816-11e9-8bee-c5df58b02c21.PNG)

	위 두 개의 테이블을 참고하여 (teaches는 강좌 )

	course_id(강좌번호)를 갖는 교수들의 이름과 그들이 가르치는 course_ID을 선택하는 쿼리문을 작성해야 한다고 해보자!

	__select__ name, course_id __from__ instructor, teaches __where__ instructor.ID = teaches.ID

	라는 쿼리문을 작성하면 된다는 것이 이해가 될 것이다.

	위와 같은 경우에서 볼 수 있듯이, 서로 다른 테이블에 이름이 같은 attribute가 있으면 각각의 서로 다른 테이블에 있는 attribute임을 명시하기 위해 __테이블이름.attribute이름__ 이라고 나타내야 한다.

	아래 두 개의 테이블과 아래 테이블을 참고하여

	Comp.Sci 전공에서 제공하는 강좌들의 정보를 찾는 쿼리문을 작성해보자. (강좌들의 course_ID와 semester, year, title을 선택하자) 

	![데이터베이스8](https://user-images.githubusercontent.com/31889335/55647078-ba06a300-5817-11e9-9c8b-1fef31bb561b.PNG)

	![데이터베이스20](https://user-images.githubusercontent.com/31889335/55686291-44771000-599a-11e9-8acb-d900e6b79d1e.PNG)


	__select__ section.course_id, semester, year, title __from__ section, course __where__ section.course_id = course.course_id __and__ dept_name = 'Comp.Sic'

	라고 작성하면 된다. 


	<br>

- _natural join에 대해서_

	__join__ 은 두 테이블을 결합하는 것을 의미한다. 중요한 것은 join한 테이블은 __column__ 의 개수가 늘어난 다는 것이다.
	즉, join 연산은 두 테이블의 열을 합치는 작업이다.

	사실 join은 데카르트의 곱셈 연산으로 만들어진다.

	예를 들어,

	![데이터베이스21](https://user-images.githubusercontent.com/31889335/55686603-43e07880-599e-11e9-9cec-9acf398b2acc.PNG)

	이 두 테이블을 join 시키면 

	![데이터베이스22](https://user-images.githubusercontent.com/31889335/55686635-9883f380-599e-11e9-9722-05524aa9285b.PNG)

	이와 같이 된다. 이때 똑같은 이름 column 이 열에 두번 들어가게 되는데 이럴 경우 이름 column을 한번만 열에 포함되도록 하는 join이 __natural join__ 이다.

	즉, 두 테이블을 join 할 때 동일한 attribute 이름과 이 attribute에 해당하는 인스턴스들이 모두 같은 column 이 있으면 이 column을 한번만 표기하는 join 연산이다.

	예를 들어, 

	__select__ * __from__ instructor __natural join__ teaches;

	라는 SQL문을 출력하면 

	![데이터베이스9](https://user-images.githubusercontent.com/31889335/55647707-4c5b7680-5819-11e9-9059-582dd7bee598.PNG)

	가 결과로 나오는데 이 결과는 instructor 테이블과 teaches 테이블을 합치는 대신 두 테이블 모두 동일한 값을 가지는 column인 ID attribute column을 한번만 쓴 테이블이다.

	_! natural join을 할 때 주의할 점 !_

	attribute 이름이 같다고 해당 attribute들이 저장된 인스턴스들은 다른 column이 join 될 수 있으니 이때는 한번만 써주면 안된다!

	


	

