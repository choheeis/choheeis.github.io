---
layout: post
title:  "[C++] 👰 C++ 잡지식들"
date:   2020-02-25 18:34:10 +0700
categories: [C++]
---

> 👩‍💻 목 차 👩‍💻
>
> - 입력, 출력 함수 속도 높이기
> - cin 특징
> - for문의 조건이 어떻게 돌아갈까?
> - C++ 전역변수 특징
> - char형 자료형을 string 자료형으로 바꾸기
> - 전역변수로 선언한 "count" 라는 변수가 모호하다! 라는 에러발생
> - const를 사용하자!



<br>

## 👰 입력, 출력 함수 속도 높이기
---

~~~c++
#include<iostream>
using namespace std;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
}
~~~

입력할 데터나 출력할 데이터가 많을 때에는 c++의 느린 입출력 함수 때문에 시간초과가 날 수 있다.

그럴 때는 위의 두 코드를 추가로 입력해서 입출력 함수의 속도를 높이자!

또 c++에서 개행할 때 사용되는 endl도 속도가 느린편이므로 endl 대신

~~~c++
#include<iostream>
using namespace std;

int main(){
	cout<<'\n';
}
~~~

와 같이 개행문자인 \n 을 사용하도록 하자!

<br>

## 👰 cin 특징
---

엔터, 스페이스바 둘 다로 입력된다.

<br>

## 👰 for문의 조건이 어떻게 돌아갈까?
---

예를 들어

~~~c++
#include<iostream>
#include<stack>
using namespace std;

int main(){
	stack<int> s;
	s.push(1);
	s.push(2);
	s.push(3);

	for(int i = 0 ; i < s.size() ; i++){
		cout<<s.top()<<'\n';
		s.pop();
	}
}
~~~

라는 코드에서 for문 안의 조건으로 쓴 i < s.size() 는 i가 증가할 때마다 바뀌게 될 것이다. 왜냐하면 s.pop() 을 통해 s의 크기가 1개씩 줄어들기 때문이다.

만약 다음과 같은 코드를 stack에 있는 데이터 출력을 위해 작성했다면 정상적으로 작동하지 않을 것이다.

for문이 한 번 돌아갈 때마다 s.size()는 3으로 고정되어 있는 것이 아니라 3, 2, 1로 바뀌기 때문이다!

즉, for문 안의 조건은 무조건 고정되어 있는 것이 아니라 i가 한 번 돌 때마다 바뀔 수 있는 값이라는 것을 알아두자!

<br>

# 👨🏻‍🏫 C++ 전역변수 특징

전역변수로 int형 변수를 선언하면 자동으로 그 변수는 0으로 초기화된다.

또, 전역변수로 bool형 변수를 선언하면 자동으로 그 변수는 false로 초기화된다.

<br>

# 👨🏻‍ char형 자료형을 string 자료형으로 바꾸기

~~~c++
#include<iostream>
#include<string>
using namespace std;

int main(){
	char ch = 'c';
	
	// string 생성자 중 n개의 char로 이루어진 string을 만드는 생성자 사용
	string str(1, ch);
}
~~~

[c++ string reference](http://www.cplusplus.com/reference/string/string/) 중 [constructor](http://www.cplusplus.com/reference/string/string/string/)에 관한 reference를 보면

![01](https://user-images.githubusercontent.com/31889335/76698251-0c1c9d80-66e4-11ea-8506-4784804a066a.PNG)

이렇게 string을 생성할 수 있는 여러가지 생성자 함수들을 볼 수 있다. 그 중 6번째 생성자 함수의 사용법을 읽어보면 n개의 char형 문자로 이루어진 string을 생성해주는 함수라는 것을 알 수 있다.

즉, string str(2, 'c'); 라고 str을 생성하고 출력해보면 cc 라고 출력될 것이다.

따라서 char형 문자 하나를 string형르로 변환하고 싶다면 string str(1, ch); 이라고 작성하면 된다!

<br>

# 🥶 전역변수로 선언한 "count" 라는 변수가 모호하다! 라는 에러발생

c++ algorithm 헤더를 선언한 후, 문제 푸는데 필요한 count라는 변수를 전역변수로 선언하였다. 

그 다음, main()에서 count++; 을 해주었는데 갑자기 에러가 발생했다!

즉, 오류난 코드를 최소화해서 보면

~~~c++
#include<iostream>
#include<algorithm>
using namespace std; 

int count = 0;

int main(){
	count++;	
}
~~~

이런 코드였고, 컴파일을 하니

![02](https://user-images.githubusercontent.com/31889335/78042652-460cc580-73ad-11ea-831d-9389618da39f.PNG)

위와 같은 오류 메시지가 떴다.

분명 count라는 변수는 내가 선언한 것인데 왜 모호하다는 것일까?

구글링을 해보았더니 다음과 같은 설명이 있었다!

__using namespace std;__ 에 의해 algorithm 헤더에 선언되어 있는 모든 이름이 가져와지게 되는데 운이 안 좋게도 algorithm 헤더에는 count라는 함수가 있다!

![03](https://user-images.githubusercontent.com/31889335/78043288-20cc8700-73ae-11ea-8024-3d65a14fded3.PNG)

따라서 count 라는 것은 내가 선언한 전역변수 이름인 동시에 algorithm 헤더 파일 안에 정의된 함수 이름이기도 해서 __ambiguous(모호한)__ 하다는 것이다!

따라서, using namespace std; 을 작성하지 않고 std::cout, std::cin, std::count 라고 해야 위의 에러가 나타나지 않게 된다...

> 참고한 블로그 --> [여기](https://xbuba.com/questions/11271889)

하지만 std를 모두 생략하기 위해 using namespace std; 를 사용하는 것이므로 나는 count 라는 변수를 cnt라고 바꾸어주었다^^

<br>

# 😛 const를 사용하자!

__상수__ 란?

다시 한번 의미를 되짚어보자.

상수는 변수의 정반대 의미로 처음 정의한 값이 절대 바뀌지 않는 저장소이다.

c++ 에서 상수를 정의하는 방법은 __const (상수의 자료형) (상수 이름) = (상수의 값);__ 이다.

단 한 개의 데이터도 상수가 될 수 있지만 배열도 상수가 될 수 있다!

예를 들어, 

~~~c++
#include<iostream>
using namespace std;

// 배열도 상수가 될 수 있다!
const int arr[4] = {0, 1, 2, 3};

int main(){

}
~~~

위와 같이 배열의 원소 개수가 정해져있고 더 이상 원소의 값이 변하지 않을 경우에는 배열에도 상수 처리를 해줄 수 있다.

const를 통해 바뀌지 않는 값들을 정의해주는게 좋은 습관인 것 같다!

<br>
