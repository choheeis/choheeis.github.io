---
layout: post
title:  "운영체제5"
date:   2019-04-13 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>u
> _🙋 5강 - CPU Scheduling 🙋_
>

<br>

## 📃 CPU 스케줄러(Scheduler)
---

- _CPU 스케줄러가 하는 일_

	프로세스의 상태에 대한 앞 포스팅에서 ready 상태에 있는 프로세스들은 CPU 스케줄러에 의해 선택된다고 언급했었다.

	ready 상태에 있는 프로세스들은 사실 __Ready Queue__ 라는 열의 형태에 들어가 있다.

	CPU 스케줄러는 이 레디큐에 있는 프로세스들 중 하나를 선택해서 CPU를 할당해 주는 일을 한다. 

	<br>

- _CPU 스케줄러가 하는 결정들은 아래와 같은 4가지 상황이 발생했을 때 일어난다_

	1. __프로세스가 running 상태에서 waiting 상태로 이동할 경우__

	2. __프로세스가 running 상태에서 ready 상태로 이동할 경우__

	3. __프로세스가 waiting 상태에서 ready 상태로 이동할 경우__

	4. __프로세스가 terminated 상태가 될 경우__

	즉, 크게 보면 다른 상태에서 ready 상태로 돌아오는 경우나 종료되는 경우이다. 

	위 4가지 경우 중에서 2번과 3번은 선점적이고, 1번과 4번은 비선점적인 스케줄링이다.

	__비선점적__ = 어떤 프로세스가 CPU를 할당받으면 이 프로세스가 종료될 때까지 계속 CPU 작업이 실행되는 것

	__선점적__ = 어떤 프로세스가 CPU를 할당받은 후, timeslice가 지나거나 I/O 이벤트를 기다려야 한다면 다른 프로세스에게 CPU를 양보하는 것(즉, 다른 프로세스가 기존 프로세스를 몰아내고 CPU를 선점할 수 있다는 것이다.)

	<br>

- _디스패처(Dispatcher)_

	CPU 스케줄러의 일을 보조 해주는 __디스패처__ 라는 것이 있다.
	
	CPU 스케줄러에 의해 선택된 프로세스에게 CPU를 할당해 주는 역할을 하는 것을 디스패처라고 한다.

	앞 포스팅에서 __context switch__ 라는 것은 프로세스1이 CPU를 할당받아서 실행되다가 타임슬라이스에 의해 중단되고, 그 다음으로 프로세스2가 실행되는 것이라고 했다.

	<br>

- _디스패처가 담당하는 3가지 일_

	__context switch 담당__

	__user모드로 바꾸기__

	__선택된 프로세서가 시작될 수 있도록 적절한 경로로 점프하기__

	> 여기서 user모드가 왜 나올까?

	CPU 스케줄링은 운영체제가 하는 일이기 때문에 __커널모드__ 에 속한다.

	즉, 프로세스를 선택하거나 선택된 프로세스로 바꾸는 것은 커널모드이지만 프로세스가 실행되는 단계는 __유저모드__ 이다.

	따라서 디스패처느 커널모드에서 user모드로 바꾸는 역할을 한다.

	<br>

- _디스패처 지연(latency)_

	디스패처가 기존 프로세스를 멈추고 선택된 프로세스를 실행시끼기까지는 약간의 시간이 걸리기 때문에 시간 지연이 발생한다.

	즉, 프로세스1에서 프로세스2로 context switch가 발생할 때 디스패처로 인한 약간의 시간 지연이 발생한다는 것이다.

	디스패처에 인한 지연을 __스케줄링 overhead__ 라고도 한다.

	<br>

## 👌 CPU 스케줄러가 프로세스를 선택하는 5가지 기준
---

- _1. CPU 이용률(utilization)을 극대화 시키는 방향으로 선택_

	CPU를 정해진 시간(time slice)동안 100% 가동하는 것에 가까운 프로세스 먼저 선택한다.

	<br>

- _2. 처리능력(throughput)을 최대화 시키는 방향으로 선택_

	주어진 시간동안 최대한 많은 프로세스를 처리할 수 있는 방향으로 선택될 프로세스 순서를 결정한다.

	<br>

- _3. 반환까지 걸리는 시간(turnaround time)을 최소화하는 방향으로 선택_

	반환까지 걸리는 시간(프로세스가 완료될 때까지의 시간)이 줄어들면 결국 전체 작업 수행 시간이 최소화 되기 때문에 turnaround time이 적은 방향으로 프로세스를 선택한다.

	<br>

- _4. 대기시간(waiting time)이 최소화되는 방향으로 선택_

	ready queue에서 기다리는 시간이 최소화 되도록 프로세스들을 선택한다.

	<br>

- _5. 응답시간(response time)이 최소화되는 방향으로 선택_

	첫 응답까지 걸리는 시간이 최소화 되는 방향으로 선택한다.

	<br>

	__위와 같은 기준들을 적용시켜서 CPU가 효과적으로 스케줄링할 수 있게 하는 알고리즘들이 존재한다!__

	<br>

## 🐍 CPU 스케줄링 알고리즘들(7가지)
---

먼저 알아둬야 할 것은 __burst time__ 이라는 것이다! 

CPU burst time은 CPU가 일을 수행하는 시간을 말하고, I/O burst time은 I/O 요청에 대한 응답을 기다리는 시간을 말한다.

<br>

- _1. First-Come First-Served(FCFS) 알고리즘_

	__FCFS__ 는 알고리즘의 이름 그대로 처음 온 프로세스가 제일 처음으로 선택되는 방식의 알고리즘이다.

	![운영체제35](https://user-images.githubusercontent.com/31889335/56301837-9296cb00-6173-11e9-80b4-803956182b57.PNG)

	위 표는 프로세스별 CPU burst time을 나타낸 표이다.

	이 표에 해당하는 프로세스들은 P1, P2, P3 순으로 ready quere에 도착했다고 가정하자.

	위와 같은 상황에서 CPU 스케줄러는 FCFS 알고리즘을 따른다고 한다면 

	![운영체제36](https://user-images.githubusercontent.com/31889335/56302116-12bd3080-6174-11e9-9ed3-adf8347c227e.PNG)

	와 같은 간트 차트가 도출된다.

	(__간트 차트(Gantt chart)__ = 프로젝트 일정관리를 위한 bar 형태의 차트)

	이 표를 보고 알 수 있는 점은 P1은 24초간 실행된 후 재등장 하지 않으므로 이 알고리즘은 비선점적이라는 점을 알 수 있다. 

	P1은 1등으로 도착하였기 때문에 대기시간이 0초이다.

	P2는 P1이 종료될 때까지 대기하여 대기시간이 24초이다.

	P3는 P1과 P2가 종료될 때까지 대기하여 대기시간이 27초이다.(24초 + 3초)

	이 세 프로세스의 평균 대기 시간은 (0 + 24 + 27)/3 이므로 17초이다.

	만약 이 때, P2를 제일 먼저 실행시켰다면 평균 대기 시간은 (0 + 3 + 27)/3 이 되어 10초로 줄어든다.

	<br>

- _2. Shortest-Job-First(SJF) 알고리즘_

	이 알고리즘도 말 그대로 CPU burst time이 가장 짧은 프로세스를 먼저 선택하는 방식의 알고리즘이다.

	단, 이 때, 프로세스가 도착한 시점에서 가장 짧은 수행시간을 갖는 것을 먼저 선택하는 것임이 중요하다!

	이 알고리즘에는 두 가지 버전이 존재한다.

	__1. 비선점적 버전__

	![운영체제37](https://user-images.githubusercontent.com/31889335/56302833-857adb80-6175-11e9-8040-3273277ac7ae.PNG)

	위 표는 프로세스별 도착 시간과 burst time을 나타낸 표이다.

	SJF 알고리즘에 따라 간트 차트를 그려보면

	![비선점적](https://user-images.githubusercontent.com/31889335/56304686-a5140300-6179-11e9-83d9-2ce966101ed3.jpg)

	위와 같은 과정으로 그려진다. (SJF에서 burst time이 같다면 먼저 도착한 프로세스를 고른다.)

	P1의 대기시간은 0초, P3의 대기시간은 3초(4초에 도착했는데 7초에 실행됨), P2의 대기시간은 6초, P4의 대기시간은 7초이다.

	이 네 프로세스의 평균 대기 시간은 (0 + 3 + 6 + 7)/4 이므로 4초이다.

	4초 밖에 되지 않으므로 SJF 알고리즘의 비선점적 버전은 프로세스의 평균 대기 시간을 최소화하는데 좋은 알고리즘이다.

	<br>

	__2. 선점적 버전__

	![선점적](https://user-images.githubusercontent.com/31889335/56305951-49974480-617c-11e9-97dd-6f36f0ed542b.jpg)

	선점적으로 프로세스를 선택한 간트 차트는 위와 같다.

	P1의 대기 시간은 9초(2초에서 중단되었다가 11초에 다시 시작되었으므로), P2의 대기 시간은 1초, P3의 대기시간은 0초, P4의 대기 시간은 2초(5초에 도착했지만 7초에 시작되었으므로)이다.

	이 네 프로세스의 평균 대기 시간은 (9 + 1 + 0 + 2)/4 이므로 3초이다.

	3초 밖에 안되므로 SJF 알고리즘의 선점적 버전도 프로세스의 평균 대기 시간을 최소화하는데 좋은 알고리즘이다.

	<br>

- _3. Priority Scheduling 알고리즘_

	이 알고리즘 또한 알고리즘 이름 그대로 우선순위가 높은 프로세스를 먼저 선택하는 방식이다.

	사실 SJF도 Priority Scheduling의 한 종류이다. 

	Priority Scheduling 알고리즘에는 문제점이 존재하는데 우선순위가 낮은 프로세스들은 선택될 일이 없다는 문제점이 있다. 이 문제점을 __starvation(굶주림)__ 이라고 한다.

	starvation 문제를 해결하기 위해서는 시간이 지날 때마다 프로세스들의 우선순위를 높여줘야 한다. 이런 해결법을 __aging(노화)__ 이라고 한다.

	<br>

- _4. Round Robin(RR) 알고리즘_

	이 알고리즘은 프로세스들 간에 우선순위를 두지 않고, 순서대로 단위시간(time slice 또는 time quantum)동안 CPU를 할당하는 방식의 알고리즘이다.

	좀 더 쉽게 말하면 모든 프로세스들을 합리적인 순서에 입각하여 선택한다는 것인데, 큐의 맨 오른쪽에서 하나씩 뽑고 단위시간이 지나면 큐의 맨 왼쪽으로 돌아가는 식이다.

	예를 들어, 레디큐안에 n개의 프로세스가 존재하고, 단위시간은 q라고 가정하자.

	위 상황에서는 어떤 프로세스도 (n-1)q 시간 보다 더 기다리는 일을 없다.

	RR 알고리즘의 효과는 q의 크기에 따라 달라진다













